יֵשׁ כמה ענינים מיוחדים בַּהִדּוּר (compilation), בקישור (linking) וּבהרצה (run)
שֶׁל תָּכְנִיּוֹת ⌘גאוה:
⌘תחילת{ספרור}
• הִדּוּר לשפת ביניים, ולא לשפת מְכוֹנָה.

• הִדּוּר רקורסיבי.

• קִשּׁוּר דינמי.

• שפת מְכוֹנָה שֶׁהִיא Strongly Typed

• שילוב שֶׁל Static Typing וְשֶׁל Dynamic Typing

⌘סוף{ספרור}

בפרק זֶה אדון בענינים אלו.

§ מבוא: הִדּוּר וַהֲרָצָה שֶׁל תָּכְנִית גָ'וָה פשוטה

הָבָה נכתוב תָּכְנִית ⌘גאוה קצרה. ראשית חכמה נכין קֹבֶץ ששמו Hello.java.
\bash[script,stdout]
cat << EOF > Hello.java
public class Hello {
  public static void main(final String[] args) {
    System.out.println("Hello, World!\n");
  }
}
EOF
\END
(במה שכתוב מעלה, הסימן ⌘
מציין אֶת הַזרז והפקודה cat מעתיקה מהקלט הסטנדרטי
אל הפלט הסטנדרטי. האידיום cat << EOF משמעו ב-bash העתקה מהקלט הסטנדרטי, עד
אֲשֶׁר בקלט תופיע שורה שבה מופיעה המילה EOF לבדה.)1

כָּעֵת, נהדר אֶת הַתָּכְנִית:
\bash[script,stdout]
javac Hello.java
\END
(הַתָּכְנִית javac הִיא הַמְּהַדֵּר שֶׁל שפת ⌘גאוה).

נבדוק כָּעֵת אלו קבצים יֵשׁ לנו:
\bash[script,stdout]
ls -lsh Hello.*
\END

כלומר, פְּקֻדַּת ההידור תירגמה אֶת קֹבֶץ הַמָּקוֹר (source file) אֲשֶׁר שמו Hello.java
לקובץ מטרה (object file) אֲשֶׁר שמו Hello.class.

נִתָּן להבחין שקובץ הַמַּטָּרָה ארוך מעט מקובץ הַמָּקוֹר: בקובץ הַמַּטָּרָה יֵשׁ
418 בתים, בעוד שבקובץ הַמָּקוֹר יֵשׁ 119 בתים.

כָּעֵת, בכדי להריץ אֶת הַתָּכְנִית יֵשׁ לכתוב

\bash[script,stdout]
java Hello
\END

ההרצה הַזּוֹ מפעילה אֶת הַקֹּבֶץ Hello.class, ומבצעת אֶת המתודה הסטטית main
שבתוכו.
אמנם הַקֹּבֶץ Hello.class הוּא קֹבֶץ בִּינָארִי, אַךְ בְּכָל זאת נִתָּן לבחון
אֶת תכנו תּוֹךְ שימוש באמצעים שונים. כָּךְ למשל, הַתָּכְנִית od מציגה אֶת תוכנו
שֶׁל קֹבֶץ בִּינָארִי:

\bash[script,stdout]
od -c Hello.class
\END

עיון בפלט מגלה שהקובץ Hello.class מכיל בתוכו סדריות (strings) טכסט מענינות.
כְּדֵי לגלות מה הן, נֹחַ להשתמש בתכנית strings:
\bash[script,stdout]
strings Hello.class
\END

בהמשך, אעמוד ביתר פירוט על תכנו ומבנהו שֶׁל קֹבֶץ ה-CLASS. בשלב זה, נשווה אֶת
הפעולות שביצענו, למה שנדרש כְּדֵי להריץ תָּכְנִית בִּשְׂפַת ⌘סי.
ראשית, נכתוב תָּכְנִית פשוטה בִּשְׂפַת ⌘סי.
\bash[script,stdout]
cat << EOF > hello.c
#include <stdio.h>
int main() {
   return printf("Hello, World!\n") !=0;
}
EOF
\END
אַחַר, נהדר אֶת הַתָּכְנִית:
\bash[script,stdout]
cc hello.c -o hello
\END

(הדגל o- מודיע למְהַדֵּר היכן לשמור אֶת קֹבֶץ הַמַּטָּרָה, במקרה זֶה לקובץ ששמו
hello)
כָּעֵת, נריץ אֶת הַתָּכְנִית:
\bash[script,stdout]
./hello
\END
הָבָה נבחן אֶת גדלי הקבצים המעורבים:
\bash[script,stdout]
ls -lsh hello hello.c
\END
נבדוק גַּם אֶת הסדריות שבקובץ הַמַּטָּרָה:
\bash[script,stdout]
strings -a hello
\END

\bash[script,stdout]
strip hello
\END

\bash[script,stdout]
strings -a hello
\END

\bash[script,stdout]
ls -ls hello hello.c
\END
נשים לב להבדלים הבאים בין שפת ⌘סי ובין שפת ⌘גאוה:
⌘תחילת{ספרור}
• קֹבֶץ הַמַּטָּרָה בִּשְׂפַת ⌘סי גדול הרבה יוֹתֵר מקובץ הַמַּטָּרָה בִּשְׂפַת
⌘גאוה.
• קֹבֶץ הַמַּטָּרָה בִּשְׂפַת ⌘גאוה מכיל הרבה יוֹתֵר מידע טכסטואלי מאשר קֹבֶץ
הַמַּטָּרָה בִּשְׂפַת ⌘סי.
• קֹבֶץ הַמַּטָּרָה בִּשְׂפַת ⌘סי נִתָּן להרצה ישירה עַל ידי הַפְּקֻדָּה hello/.
. לעומת זאת, יֵשׁ להשתמש בפקודה מיוחדת כְּדֵי להריץ אֶת קֹבֶץ הַמַּטָּרָה
בִּשְׂפַת ⌘גאוה, כלומר, היה עלינו לכתוב java Hello.
הַ-JVM
⌘סוף{ספרור}

כפי שראינו לעיל, תָּכְנִיּוֹת ב-⌘גאוה אינן מהודרות (Compiled) לשפת המכונה עליה
תופעל הַתָּכְנִית. במקום זאת, הַתָּכְנִית מהודרת לשפה אחרת, שפת מְכוֹנָה שֶׁל
מְכוֹנָה וירטואלית. הַקֹּבֶץ Hello.class מכיל, פרט לסדריות הטכסט שגילינו למעלה,
פְּקֻדּוֹת לביצוע עֲבוּר המכונה הַזּוֹ.

שֵׁם המכונה הַזּוֹ הוּא הַ-⌘גאוה Virtual Machine ובקיצור הַ-JVM. הַ-JVM אינה
קיימת במציאות כדרך שאתה, הקורא קיים. הִיא אינה תופסת נפח במרחב הפיסי, ואי אפשר
למשש או לרחרח אותה. אבל, הִיא קיימת בְּכָל זאת – בכך שיש לה מפרט מפורט ביותר:
\begin{english}
\url{http://java.sun.com/docs/books/jvms/}
\end{english}

וישנה תָּכְנִית מחשב הַמממשת אֶת המפרט הזה. כלומר, ישנה תָּכְנִית מחשב הקוראת
אֶת הפקודות שֶׁל הַ-JVM מפענחת אותן, ומבצעת אותן, ממש כשם שישנה מְכוֹנָה פיסית,
מוחשית, הקוראת אֶת הפקודות שֶׁל הַ-8086 ומבצעת אותן. הַתָּכְנִית הַזּוֹ נקראת
פעמים רבות גַּם הִיא הַ-JVM.

אפשר לממש אֶת הַ-JVM בִּשְׂפַת ⌘סי, וכך בדרך כלל עושים. נִתָּן גַּם לממש אותו
בשפות עיליות אחרות או בִּשְׂפַת המכונה (למשל 8086 Assembly). נִתָּן אפילו לממש
אֶת הַ-JVM בִּשְׂפַת ⌘גאוה. רקורסיה כזוֹ, בבחינת „צבת בצבת עשוייה“ הִיא מעט
מבלבלת, ונניח לה.

הִדּוּר שֶׁל תָּכְנִית ⌘גאוה משמעו תרגום תָּכְנִית בִּשְׂפַת ⌘גאוה לתכנית שקולה
לשפה שאותה מכירה מכונת הַ-JVM – לשפה הַזּוֹ קוראים ⌘גאוה Byte Code.

ישנו מספר לֹא קטן שֶׁל מימושים ל-JVM. ערך הויקיפדיה
\begin{english}
\url{http://en.wikipedia.org/wiki/Listₒfⱼavaᵥirtualₘachines}
\end{english}

מונה, לעת כתיבת ספר זֶה, כמעט שישים מימושים שונים. המימוש הנפוץ ביותר הוּא ככל
הנראה זֶה שֶׁל חברת Sun.

מימוש שֶׁל הַ-JVM הוּא תלוי מְכוֹנָה ותלוי מערכת הפעלה. אבל, מהרגע שהותקן במחשב
מסויים מימוש כלשהו שֶׁל הַ-JVM. נִתָּן להריץ עליו כָּל תָּכְנִית הכתובה
בִּשְׂפַת הַ-⌘גאוה Byte Code.

אֲשֶׁר עַל כן, כאשר כתבנו למעלה:

\bash[script,stdout]
java Hello
\END

הרצנו אֶת הַ-JVM (הַפְּקֻדָּה java משמעה הפעלת הַ-JVM), והורינו לו להתחיל לבצע
אֶת פְּקֻדּוֹת הַ-⌘גאוה Byte Code אֲשֶׁר בקובץ Hello.class.

ארכיטקטורה זוֹ מאפשרת לכן להריץ תָּכְנִיּוֹת ⌘גאוה עַל כָּל מחשב, ללא צורך בהתקנה
מיוחדת. בדוגמא שלנו, נוכל לקחת אֶת הַקֹּבֶץ Hello.class ולהעתיק אותו למכונת DOS
למשל, ולהריץ אֶת הַתָּכְנִית שֵׁם בדיוק באותו אופן:

\begin{NONE}
C:\> java Hello
Hello, World!
\end{NONE}

לעומת זאת, אִם נעתיק אֶת הַקֹּבֶץ הבינארי hello שהכנתי מתכנית ⌘סי למכונת DOS לֹא
נוכל להפעילו שֵׁם.

יתרון נוסף שֶׁל האכיטקטורה הוּא שה JVM הוּא "בטוח", במובן זֶה, שבניגוד להרצה
ישירה עַל המכונה, הַ-JVM תוחם אֶת מרחב הפעולה שֶׁל תָּכְנִיּוֹת המופעלות עליו –
ויכול למנוע מהן לבצע פעולות שאינן מותרות להן, כמו גישה לכתובות זיכרון לֹא
חוקיות. הארכיטקטורה מאפשרת עַל כן להפעיל תָּכְנִיּוֹת מחשב המגיעות ממקור לֹא
מוכר (אתר כלשהו באינטרנט), ולהריצן ב"ארגז החול" (Sand box) שֶׁל הַ-JVM, כאשר
הַתָּכְנִית, כָּל כמה שתנסה, אינה יכולה לצאת מהארגז.

בדוגמא שלנו, אפילו אִם היינו משנים באמצעים חיצוניים אֶת הַקֹּבֶץ Hello.class לֹא
היינו יכולים, עד כמה שננסה להיות זדוניים, לגרום להרצה שֶׁל הַקֹּבֶץ
\begin{NONE}
C:\> java Hello
\end{NONE}

לקרוא כתובות בזיכרון המחשב, שאסור לה לקרוא, או גרוע מכך, לכתוב לכתובות בזיכרון
שאסור לכתוב אליהן.

החיסרון העיקרי שֶׁל ארכיטקטורה הַ-JVM הוּא ביצועים ירודים. ביצוע שֶׁל תָּכְנִית
⌘גאוה עַל מְכוֹנָה וירטואלית עלול להיות אלפי מונים איטי יוֹתֵר מביצוע שֶׁל
תָּכְנִית שקולה בשפה אחרת, המהודרת לביצוע ישירות עַל המכונה הפיזית. עַל חיסרון
זֶה מתגברים באמצעות טכנולוגיות שונות, שהחשובה בהן הִיא הַ- Just In Time
compiler, הידוע לעיתים גַּם בשם הקצר JIT Compiler או סתם JIT.

הַ-JIT הוּא מרכיב שֶׁל מימוש שֶׁל הַ-JVM, אֲשֶׁר מזהה קטעים בתכנית המתבצעת
אֲשֶׁר מתבצעים שוב ושוב, ומתרגם אותם, תּוֹךְ כְּדֵי ריצה לשפת המכונה הפיזית, מה
שמביא לשיפור עצום במהירות הביצוע.

נבדוק אֶת זמן הריצה שֶׁל תָּכְנִית הַ-⌘גאוה שכתבנו,
\bash[verbose,script,stdout,stderr]
/usr/bin/time java Hello
\END

נבדוק כעת אֶת זמן הריצה שֶׁל תָּכְנִית הַ-⌘סי המקבילה:

\bash[script,stdout,stderr]
time ./hello
\END

בקירוב, אנו מקבלים שתכנית הַ-⌘סי רצה יוֹתֵר מפי 300 מהר יוֹתֵר מתכנית הַ-⌘גאוה.
אבל, ההבדל אותו מדדנו כאן, אינו נובע כולו מזמני הביצוע שֶׁל תָּכְנִית הַ-⌘גאוה
הקצרה כל כָּךְ שלנו, אלא מהעובדה, שכדי להפעיל תָּכְנִית ⌘גאוה יש לאתחל אֶת
הַ-JVM. נבדוק למשל אֶת זמן הריצה שֶׁל תָּכְנִית ⌘גאוה אֲשֶׁר אינה קיימת:

\bash[script,stdout,stderr]
/usr/bin/time java NoSuchClass
\END

אנו רואים שזמן הריצה בעֲבוּר מַחְלָקָה שאינה קיימת, הוא 326 מילישניות, לעומת 344
מילישניות בעֲבוּר הַמַּחְלָקָה Hello.

למרות השם, אֵין לשפת ⌘גאוה בעלות עַל שפת הַ-⌘גאוה Byte Code. מסתבר שיתרון הזמינות
(עַל מחשבים רבים ושונים) כמו גַּם יתרון היבילות (Portability) שֶׁל הקוד המהודר
ושיקולים אחרים מביאים לתוצאה ששפות אחרות גַּם הן מהודרות לשפה זוֹ .

רשימה חלקית שֶׁל שפות הניתנות להידור לשפת ה-JVM מופיעה כאן:

\begin{english}
\url{http://en.wikipedia.org/wiki/Listₒf_JVMₗanguages}
\end{english}

§הִדּוּר תָּכְנִיּוֹת ⌘גאוה

תָּכְנִית ⌘גאוה מורכבת מקבצים, כאשר בְּכָל קֹבֶץ נמצאת הגדרה שֶׁל מַחְלָקָה
(Class)
 אחת ראשית שֶׁשְּׁמָהּ זהה לשם הַקֹּבֶץ,
ולעיתים הגדרה שֶׁל מַחְלְקוֹת
משנה: בדרך כלל מחלקות המשנה הינן מחלקות מקוננות במחלקה הראשית, ולעיתים גַּם
הגדרה שֶׁל מחלקות אחרות, מחלקות משניות, שאינן מקוננות במחלקה הראשית. השימוש
במחלקות משניות הוּא נדיר.

גַּם בתוך הַמַּחְלָקוֹת המשניות נִתָּן להגדיר מחלקות מקוננות, אַךְ השימוש בכך
נדיר ביותר.

בדרך כלל, מספיק לְהַדֵּר רק קֹבֶץ אחד, הַקֹּבֶץ המכיל אֶת הַמַּחְלָקָה שבה מתחיל
הביצוע שֶׁל הַתָּכְנִית, וזאת, אפילו אִם הַתָּכְנִית משתמשת במחלקות רבות אחרות.
הִדּוּר הַקֹּבֶץ הזה, יגרום למְהַדֵּר לחפש אֶת כָּל הַמַּחְלָקוֹת האחרות שבהן
עושה שימוש הַמַּחְלָקָה הַזּוֹ, ולהדר אותן במידת הצורך.

כְּדֵי שהַמְּהַדֵּר שֶׁל ⌘גאוה יוכל לבצע חיפוש זֶה, הוּא חייב לדעת היכן יֵשׁ לבצע
אֶת החיפוש. נזכר בארגון שֶׁל הַמַּחְלָקוֹת בשפה. כָּל מַחְלָקָה ב-⌘גאוה מצוייה
בחבילה (Package), כאשר כָּל חבילה מהווה מרחב שמות אחד, והחבילות כולן מאורגנות
במבנה שֶׁל עץ. כָּךְ למשל תָּכְנִיּוֹת שנכתבות בפקולטה למדעי המחשב בתכניון,
צריכות להמצא בחבילה אשר שמה הוּא

il.ac.technion.cs

כלומר, בחבילה שֶׁשְּׁמָהּ הוּא cs המצוייה בחבילה שֶׁשְּׁמָהּ הוּא technion
המצוייה בחבילה שֶׁשְּׁמָהּ הוּא ac המצוייה בחבילה שֶׁשְּׁמָהּ הוּא il. נשים לב
ששמות החבילות בם בחרנו מצייתים למוסכמה שֶׁל שפת ⌘גאוה לפיה, שֵׁם החבילה מתחיל
בכתובת הַ-domain שֶׁל הארגון אֲשֶׁר כתב אותה, כאשר מרכיבי הכתובת נמצאים בסדר
הפוך.

כמובן, אֵין מניעה להקים חבילות נוספות בתוך החבילה il.ac.technion.cs. כָּךְ למשל,
מחלקות האחראיות עַל ביצוע משימה שֶׁל טיפול בסדריות (strings) ואשר פותחו בפקולטה
יכולות למשל להמצא בחבילה

il.ac.technion.cs.strings

ישנו מיפוי היררכי שֶׁל מבנה העץ שֶׁל החבילות לתת-עץ שֶׁל מערכת הקבצים. כָּל
הַמַּחְלָקוֹת השייכות לחבילה

 il.ac.technion.cs.strings

ימצאו עַל כן בתיקיה שֶׁשְּׁמָהּ הוּא:

/Ã/ac/technion/cs/strings

כאשר הסימן Ã מציין אֶת המקום שבו מתחיל תת העץ שֶׁל מערכת הקבצים עליו מאוחסנות
התכניות.

נסתכל למשל עַל מַחְלָקָה שֶׁשְּׁמָהּ הוּא StringParser המוגדרת בחבילה
שֶׁשְּׁמָהּ הוּא

 il.ac.technion.cs.strings

כלומר מַחְלָקָה שֶׁשְּׁמָהּ המלא

il.ac.technion.cs.strings.StringParser

אזי, אִם למשל בחרנו למפות אֶת עץ החבילות לתיקיה

 /home/yogi/java

הרי הַמַּחְלָקָה תמצא בקובץ ששמו הוּא

/home/yogi/java/ac/technion/cs/strings/StringParser.java

יתירה מכך, אִם הַמַּחְלָקָה הודרה כבר ל-⌘גאוה Byte Code הרי תוצאת ההידור תשמר
בקובץ בעל שֵׁם זהה, אלא שהסיומת שלו תהיה class. בדרך כלל קֹבֶץ זֶה ימצא באותו
מקום שבו נמצא קֹבֶץ הַמָּקוֹר, כלומר שֵׁם הַקֹּבֶץ המהודר המלא יהיה:

/home/yogi/java/ac/technion/cs/strings/StringParser.class

כְּדֵי לאתר אֶת הַקֹּבֶץ, הַמְּהַדֵּר חייב לקבל אֶת מיקום נקודת העיגון - שֵׁם
התיקיה במערכת הקבצים ממנו מתחיל המיפוי. בדרך כלל, המיפוי שֶׁל עץ הַמַּחְלָקוֹת
הוּא בו זמנית למספר מקומות, שיכולים לכלול נקודות שונות בהיררכיית מערכת הקבצים,
שמות שֶׁל קבצי ארכיב (קבצים בעלי סיומתzip או סיומת jar) המכילים בתוכם, בפורמט
דחוס, עצים שלמים, וכן גַּם כתובות URL המכילות בתוכן אֶת הַמַּחְלָקוֹת לביצוע.

רשימת המקומות בהם יֵשׁ לחפש מחלקות נודעת בשם CLASSPATH. נניח שערכו שֶׁל
הַ-CLASSPATH הוּא הרשימה בת שתי התיקיות:

1. /home/yogi/java
2. /home/yogi/import/lib

נניח גַּם שהמחלקה StringParserDemo (אשר קוֹד הַמָּקוֹר שלה מצוי בקובץ
StringParserDemo.java) עושה שימוש במחלקה אשר שמה המלא הוּא
il.ac.technion.cs.strings.StringParser

כְּדֵי לְהַדֵּר אֶת StringParserDemo, יֵשׁ ראשית לקבוע אֶת הַ-CLASSPATH. הקביעה
נעשית עַל ידי יצוא משתנה סביבה (environment variable). לדוגמא ב-bash נכתוב

export CLASSPATH=/home/yogi/java:/home/yogi/import/lib

ולאחר מכן להפעיל אֶת פְּקֻדַּת ההידור הבאה:

javac StringParserDemo.java

נִתָּן גַּם להעביר אֶת ה-CLASSPATH כפרמטר למהדר, בפקודה שבה אנו מפעילים אותו:

javac -classpath /home/yogi/java:/home/yogi/import/lib StringParserDemo.java

אַךְ שיטה זוֹ יעילה פחות, שכן בדרך כלל, נשתמש בקביעה שֶׁל ה-CLASSPATH לתכניות
נוספות (למשל java) ולהרצות רבות שֶׁל הַמְּהַדֵּר.

בין כָּךְ ובין כָּךְ, הַמְּהַדֵּר יהדר אֶת הַקֹּבֶץ הנתון, וייצר קֹבֶץ המכיל אֶת
הפקודות המתאימות בִּשְׂפַת הַ-⌘גאוה ByteCode. התוצאה תימצא בְּקֹבֶץ אֲשֶׁר שמו
StringParserDemo.class אולם, יחד עִם זאת, הַמְּהַדֵּר יוודא שגם הַמַּחְלָקָה

 il.ac.technion.cs.strings.StringParser

קיימת ומהודרת. לשם כָּךְ, הוּא יחפש ראשית בתיקיה

/home/yogi/java/ac/technion/cs/strings/

ואח"כ-בתיקיה:

/home/yogi/import/lib/ac/technion/cs/strings/

החיפוש יכול להביא לאחת מבין שלוש תוצאות:

⌘תחילת{ספרור}

• מציאת קֹבֶץ מקור. אִם באחת משתי התיקיות הַמְּהַדֵּר מוצא אֶת הַקֹּבֶץ
StringParser.java אז הַמְּהַדֵּר בודק אִם גַּם הַקֹּבֶץ StringParser.class נמצא
שֵׁם.

אִם הַקֹּבֶץ StringParser.class לֹא נמצא, או שהתאריך שלו מוקדם לתאריך שֶׁל קֹבֶץ
הַמַּטָּרָה הצמוד אליו, StringParser.class אז הַמְּהַדֵּר יהדר אֶת הַקֹּבֶץ
StringParser.java כְּדֵי ליצר אֶת StringParser.class באותה תיקיה.

הסבר: אִם הַקֹּבֶץ StringParser.class לא קיים, ברור שיש צורך להדר את הקובץ את
StringParser.java כדי ליצר אותו. אִם StringParser.class קיים, אך התאריך שלו
מוקדם לתאריך של הקובץ StringParser.java, נראה שקובץ הַמָּקוֹר StringParser.java
השתנה לְאַחַר שהודר, ועל כן יש להדרו שוב.

• מציאת קֹבֶץ מטרה, ללא קֹבֶץ מקור. אִם הַקֹּבֶץ StringParser.java לֹא נמצא באף
אחת משתי התיקיות, ובאחת מהתיקיות נמצא הַקֹּבֶץ StringParser.class אז הַמְּהַדֵּר
ממשיך הלאה.

• העדר קֹבֶץ מטרה וקובץ מקור. אִם לֹא StringParser.java ולא StringParser.class
מצויים באף לֹא אחת מהתיקיות, הַמְּהַדֵּר מודיע הודעת שגיאה ועוצר.
⌘סוף{ספרור}

פעולת החיפוש וההידור עַל פי הצורך נמשכת עד אֲשֶׁר כָּל הַמַּחְלָקוֹת בהן משתמשת
הַמַּחְלָקָה המקורית, אִם באורח ישיר, ואם באורח עקיף, מהודרות. (אִם המהדר מאתר
רק אֶת קֹבֶץ הַמַּטָּרָה שֶׁל מַחְלָקָה מסויימת, הוא אינו מחפש אֶת הַמַּחְלָקוֹת
שבהן מַחְלָקָה זוֹ משתמשת.)

לְאַחַר שהַמְּהַדֵּר איתר (או יצר) אֶת הַקֹּבֶץ StringParser.class הוּא מחלץ
ממנו אֶת רשימת כָּל המתודות המוגדרות במחלקה, ורשימת כָּל המשתנים המוגדרים
במחלקה, ובודק שהשימוש שֶׁל הַמַּחְלָקָה StringParserDemo במחלקה StringParser היה
נכון מבחינת הטיפוסים, כלומר שהפרמטרים למתודות שֶׁל StringParser היו בדיוק לפי
הטיפוסים המוכרזים במחלקה StringParser, שטיפוס ערך החזרה שֶׁל המתודות הוּא בדיוק
לפי מה שהוגדר במחלקה, וכל מה שצריך לבדוק כְּדֵי לבצע בדיקה מלאה שֶׁל Static
Typing.

(כרגיל, התהליך המלא מכיל פרטים רבים נוספים. כָּךְ למשל, נִתָּן להגדיר CLASSPATH
נפרד עֲבוּר קבצי ⌘גאוה וְ CLASSAPTH נפרד עֲבוּר קבצים המכילים ⌘גאוה ByteCode,
והתהליך אף מורכב יוֹתֵר בעֲבוּר קבצים המכילים מספר מחלקות.)

הִדּוּר תָּכְנִיּוֹת ⌘גאוה אפשרי גַּם כאשר יֵשׁ תלות מעגלית. טלו למשל מַחְלָקָה A
התלוייה במחלקה B כאשר הַמַּחְלָקָה B תלוייה מצידה במחלקה A. אז בהידור שֶׁל
הַמַּחְלָקָה A, הַמְּהַדֵּר יוצר מהמחלקה A קֹבֶץ A.class תּוֹךְ הנחה שהמחלקה B
נכונה, ומהמחלקה B קֹבֶץ B.class מתוך הנחה שהמחלקה A נכונה. לְאַחַר מכן,
הַמְּהַדֵּר בודק שהקובץ A.class הוּא עקבי עִם הַקֹּבֶץ B.class ולהפך.

אנו רואים שתהליך ההידור שֶׁל מַחְלָקָה ב-⌘גאוה עשוי להיות כרוך בבדיקת טיפוסים
שֶׁל כל הַמַּחְלָקוֹת בהן היא משתמשת.

כְּדֵי להבין אֶת תהליך ההידור הרקורסיבי טוב יוֹתֵר, ניצור שלוש מחלקות קצרות
ביותר: הַמַּחְלָקָה A1, הַמַּחְלָקָה A2 והמחלקה A3, כאשר הַמַּחְלָקָה A1 משתמשת
במחלקה A2, וזוֹ משתמשת במחלקה A3.

\bash[script,stdout]
rm -f A[1-3].java
echo "public class A1 { public A1() { new A2(); }}" > A1.java
echo "public class A2 { public A2() { new A3(); }}" > A2.java
echo "public class A3 { }" > A3.java
\END

ארבעת הפקודות המשורשרות לעיל יוצרות שלושה קבצים, ששמותיהם מתאימים לשלושת
המחלקות. הַבַּנַּאי של הַמַּחְלָקָה A1 יוצר עצם מהמחלקה A2, והבנאי של
הַמַּחְלָקָה A2 יוצר עצם מהמחלקה A3. הַמַּחְלָקָה A3 היא ריקה. (הפקודה הראשונה
מוחקת את הקבצים אם היו קיימים לפני כן.)
כעת נהדר אֶת הַמַּחְלָקָה A1, ונבקש מהמהדר לדווח על מעשיו:
\bash[script,stdout,stderr]
javac -verbose A1.java
\END

נשים לב שהמהדר מחפש קבצי class בשורה ארוכה שֶׁל מקומות ובהם קבצי הארכיב הבאים:
resources.jar, rt.jar, sunrsasign.jar, jsse.jar,jce.jar, charsets.jar, netx.jar,
plugin.jar, rhino.jar המצויים כולם בתיקיה

/usr/lib/jvm/java-6-openjdk/jre/lib/

וכן בקובץ הארכיב jdk.boot.jar המצוי בתיקיה

/usr/lib/jvm/java-6-openjdk/jre/lib/modules/

וכמו כן, גם בתיקיה

/usr/lib/jvm/java-6-openjdk/jre/classes

ועוד במקומות רבים ושונים. באחד מבין המקומות הללו המהדר מוצא אֶת הַמַּחְלָקָה
java.lang.Object (ממנה יורשות כל הַמַּחְלָקוֹת ב-⌘גאוה, ובפרט גַּם הַמַּחְלָקָה
A1). נשים לב לכך שהמהדר אינו מחפש מחלקות אחרות שבהן עושה שימוש הַמַּחְלָקָה
java.lang.Object.

כְּדֵי לְהַדֵּר אֶת הַמַּחְלָקָה A1 יש לאתר אֶת הַמַּחְלָקָה A2. הַ-CLASSPATH
במקרה שלנו הוא ריק, ולכן המהדר מחפש אֶת הַמַּחְלָקָה A2 בתיקיה הנוכחית, וכיוון
שהוא מוצא שֵׁם אֶת הקובץ A2.java הוא מהדר אותו, תּוֹךְ שהוא מודיע:

[checking A1]
[loading ./A2.java]
[parsing started ./A2.java]
[parsing completed 0ms]
[wrote A1.class]

אבל, הפעולה אינה שלמה, שכן כְּדֵי לְהַדֵּר אֶת הַמַּחְלָקָה A2 המהדר צריך גַּם
לאתר ולהדר אֶת הַמַּחְלָקָה A3 שבה עושה שימוש הַמַּחְלָקָה A2. הודעות המהדר הן:

[checking A2]
[loading ./A3.java]
[parsing started ./A3.java]
[parsing completed 1ms]
[wrote ./A2.class]

השלב האחרון הוא ההידור שֶׁל הַמַּחְלָקָה A3, אֲשֶׁר אינה עושה שימוש במחלקות
אחרות. הודעות המהדר הן על כן מועטות בעֲבוּר מַחְלָקָה זוֹ :

[checking A3]
[wrote ./A3.class]

מה יקרה אִם ננסה לְהַדֵּר אֶת הַמַּחְלָקָה A1 פעם נוספת, מבלי לשנות אף אחת
מהמחלקות?

\bash[script,stdout,stderr]
javac -verbose A1.java
\END

כפי שרואים לעיל, המהדר מהדר אֶת הַמַּחְלָקָה A1, ולשם כָּךְ הוא מאתר אֶת הקובץ
A2.class וכיוון שקובץ זה מעודכן יוֹתֵר מהקובץ A2.java, המהדר אינו טורח לבדוק אֶת
הַמַּחְלָקָה A3.
§ מבנה קֹבֶץ CLASS

כפי שראינו, בְּקֹבֶץ CLASS יֵשׁ מידע מספיק המאפשר לבדוק אֶת הטיפוס שֶׁל כָּל
תָּכְנִית המשתמשת בו. בְּכָל קֹבֶץ כזה ישנם שלושה חלקים עיקריים:

⌘תחילת{ספרור}
• כותרת Header: מספר קטן שֶׁל בתים, המזהה אֶת הַקֹּבֶץ.
• טבלאות Pool: המכילות אֶת רשימת כָּל הסדריות בהן משתמשת הַמַּחְלָקָה, רשימת
כָּל הַמַּחְלָקוֹת האחרות בהן משתמשת הַמַּחְלָקָה, רשימת המתודות בהן משתמשת
הַמַּחְלָקָה, וכן אֶת רשימת המתודות והמשתנים המוגדרים במחלקה.
• Byte code: הפקודות בִּשְׂפַת הַ-⌘גאוה Byte Code שיש בגוף המתודות.
⌘סוף{ספרור}

במאמץ לֹא גדול נִתָּן לזהות מקצת ממרכיבים אלו בפלט שֶׁל סקירת הַקֹּבֶץ
%\bash[script,stdout]
Hello.class:

<init>
Code
LineNumberTable
main שֵׁם המתודה היחידה במחלקה זוֹ
([Ljava/lang/String;)V טיפוס הארגומנט למתודה זוֹ, מערך שֶׁל
סדריות
SourceFile
Hello.java
Hello, World! הסדרית אותה תדפיס הַתָּכְנִית
Hello
java/lang/Object הַמַּחְלָקָה ממנה יורשת
הַמַּחְלָקָה הַזּוֹ
java/lang/System מַחְלָקָה בה משתמשת הַמַּחְלָקָה
הַזּוֹ
Ljava/io/PrintStream; עוד מַחְלָקָה בה משתמשת הַמַּחְלָקָה
הַזּוֹ
java/io/PrintStream אזכור נוסף שֶׁל מַחְלָקָה בה משתמשת
הַמַּחְלָקָה הַזּוֹ
println שֵׁם שֶׁל מתודה לה קוראת מתודה במחלקה זוֹ
(Ljava/lang/String;)V עוד מַחְלָקָה בה משתמשת הַמַּחְלָקָה
הַזּוֹ
%\END

כדאי לדעת כי בקובץ ה-CLASS המילה <init> מציינת את השם של הַבַּנַּאי
(Constructor) של הַמַּחְלָקָה.
בְּכָל זאת, הפענוח אינו קל. ישנן תָּכְנִיּוֹת רבות המדפיסות אֶת התוכן שֶׁל קבצי
CLASS באופן הקריא לבני תמותה. הנה פלט שֶׁל אחת מהן. בתוך הפלט, הוספתי, בשפה
העברית ובכתב יד, מעט הסברים.
\bash[script,stdout]
jcf-dump Hello.class
\END

נִתָּן להשתמש גַּם ב- jcf-dump בכדי לראות אֶת הַ-Byte Codes שֶׁל שתי המתודות
(מודגש בפלט הבא):

\bash[script,stdout]
jcf-dump -c Hello.class
\END

אנו רואים שבקובץ הַ-CLASS יֵשׁ מידע מספיק כְּדֵי לזהות אֶת הטיפוס המלא שֶׁל כָּל
המתודות, ולכן אפשר להשתמש בקובץ כְּדֵי לבדוק אִם השימוש היה תקין. למעשה, נִתָּן
בקלות לשחזר אֶת ה"חתימה" שֶׁל הַמַּחְלָקָה המקורית מקובץ הַ-CLASS (החתימה
מוגדרת, באורח לֹא פורמלי, כקוד המקורי, במחיקת ההערות והפקודות לביצוע):

\bash[script,stdout]
javap Hello
\END

הֲרָצָה שֶׁל תָּכְנִיּוֹת ⌘גאוה
כאמור, הֲרָצָה שֶׁל הַפְּקֻדָּה java הִיא הפעלה שֶׁל הַ-JVM. הַ-JVM הינו
תָּכְנִית שבמרכזה מנוע (engine) המבצע אֶת מחזוֹר הפעולות הרגיל שמבצעת יחידת
העיבוד המרכזית (CPU) במכונה פיזית:
⌘תחילת{ספרור}
• קידום הַ-Program Counter
• איחזור הַפְּקֻדָּה הבאה
• פענוח הַפְּקֻדָּה
• ביצוע הַפְּקֻדָּה
⌘סוף{ספרור}
כאשר משתנים בתוך המנוע שֶׁל הJVM מדמים אֶת האוגרים (Registers) שֶׁל המכונה
הוירטואלית, מערכים בתוכו מדמים אֶת מרחב הזיכרון, ועוד.
ישנם חלקים נוספים מלבד המנוע בתוך הַ-JVM. החשוב שבין אלו הוּא טוען הַמַּחְלָקוֹת
(Class Loader). בְּכָל עת שהביצוע שֶׁל המנוע מגיע לפקודה שבה יֵשׁ גישה למחלקה
אחרת, אִם למתודה ואם לשדה, נכנס לפעולה טוען הַמַּחְלָקוֹת, ומוודא שהמחלקה
המבוקשת טעונה.
נזכר בַּ-Byte Code שֶׁל המתודה main במחלקה Hello שראינו למעלה:

  0: getstatic <Field java.lang.System.out java.io.PrintStream>
הַפְּקֻדָּה לעיל מבקשת לאחזר אֶת השדה הסטטי out שבמחלקה java.lang.System עַל כן,
טוען הַמַּחְלָקוֹת יכנס לפעולה, ויוודא שהמחלקה java.lang.System טעונה. מכיוון
שהטיפוס של שדה זו הוא java.io.PrintStream

הַפְּקֻדָּה לעיל מבקשת לקרוא למתודה הוירטאולית println (המקבלת כפרמטר String
והמחזירה void) אֲשֶׁר במחלקה java.io.PrintStream, ועל כן, טוען הַמַּחְלָקוֹת
יכנס טרם ביצוע הַפְּקֻדָּה לפעולה, ויבדוק שהמחלקה java.io.PrintStream אכן טעונה.

לטוען הַמַּחְלָקוֹת יֵשׁ טבלא גדולה שבה יֵשׁ רשימה שֶׁל כָּל הַמַּחְלָקוֹת
אֲשֶׁר נטענו כבר. אִם הַמַּחְלָקָה מצוייה בטבלא, הביצוע שֶׁל המנוע ממשיך כרגיל.

אַךְ, אִם הַמַּחְלָקָה המבוקשת אינה מצוייה בטבלת הַמַּחְלָקוֹת הטעונות, שומה עַל
טוען הַמַּחְלָקוֹת להשתמש ב-CLASSPATH כְּדֵי לאתר אֶת קֹבֶץ הַ-CLASS שֶׁל
הַמַּחְלָקָה אותה הוּא מבקש.

שיטה זוֹ, שֶׁל טעינת קוֹד לביצוע בזמן ריצה קרוייה Dynaminc Loading. היתרון שֶׁל השיטה
הוּא בכך שאין צורך לטעון חלקי תָּכְנִית שאולי לֹא יבוצעו. החסרון הוּא שיתכן כי בזמן
ריצה יתגלה שהחלקים הנדרשים חסרים, או שאינם תקינים.

טעינת הַמַּחְלָקָה דורשת איתור שֶׁל הַקֹּבֶץ, קריאתו, בדיקתו, ואתחול הַמַּחְלָקָה. לְאַחַר שאותר
הַקֹּבֶץ קורא אותו טוען הַמַּחְלָקוֹת, ובודק אותו דקדוקית וטכנית. אחרי הבדיקה הדקדוקית
טכנית, מתבצעת בדיקה שֶׁל טיפוסים: הטוען בודק שהטיפוסים המוגדרים בקובץ תואמים אֶת
השימוש בקובץ.

נשים לב לכך שבדיקה זוֹ הִיא בנוסף לבדיקה שהתבצעה בזמן הִדּוּר, והיא מיועדת להגנה
בפני טעויות וזדון: מקרים שבהם השתנה קֹבֶץ הַ-CLASS לְאַחַר ההידור.

שגיאות המתגלות בשלב זֶה תגרומנה להפסקת ביצוע הַתָּכְנִית.

§ הַמְּאַמֵּת

הבדיקה שֶׁל קֹבֶץ הַ-CLASS אינה מתמצית בבדיקה הטכנית הדקדוקית. שפת הַ-⌘גאוה Byte
Code הִיא Strongly Typed בכך שלא יתכן כי תופעל פעולה שאינה מתאימה לטיפוס שֶׁל
ערך מסויים. יחד עִם זאת, אֵין בְּקֹבֶץ הַ-CLASS מידע לגבי הטיפוס שֶׁל כָּל אוגר
ואוגר.

בתוך טוען הַמַּחְלָקוֹת ישנו מרכיב חשוב, הַמְּאַמֵּת, הידוע גַּם בשם Byte Code
Verifier, אֲשֶׁר תפקידו לבדוק שהַ-Byte Code אינו מבצע שגיאת טיפוס. הַמְּאַמֵּת
נכנס לפעולה עִם טעינת הַמַּחְלָקָה לזכרון, ופעולתו מבוססת עַל השלבים הבאים:

⌘תחילת{ספרור}
• חלוקת הקוד לביצוע לבלוקים בסיסיים. בלוק בסיסי הוּא סדרה שֶׁל פְּקֻדּוֹת
מְכוֹנָה רצופות המתבצעות תמיד יחד. אֵין פְּקֻדַּת קפיצה (goto) אל תּוֹךְ הבלוק,
ואין פְּקֻדַּת קפיצה מתוך הבלוק. הַפְּקֻדָּה האחרונה בבלוק בסיסי תהיה עַל כן
תמיד פְּקֻדָּה המשנה אֶת הסדר הרגיל שֶׁל הביצוע: פְּקֻדַּת קפיצה בלתי מותנית
(simple goto), פְּקֻדַּת קפיצה מותנית (conditional goto) פְּקֻדַּת חזרה
(return) וכו'.

• בנית גרף המעברים האפשריים בין הבלוקים הבסיסיים. שני בלוקים יחוברו בקשת מכוונת
בגרף זֶה, אִם יתכן שהם יבוצעו ברציפות.

• איתור האוגרים שבהם נעשה שימוש בְּכָל בלוק בסיסי.

• איתור פְּקֻדּוֹת המחסנית שבכל בלוק בסיסי

⌘סוף{ספרור}

לְאַחַר מכן, מנסה הַמְּאַמֵּת לפתור מערכת משוואות, שבה הנעלמים הם:

⌘תחילת{ספרור}
• הטיפוסים שֶׁל כָּל הערכים השמורים באוגרים בְּכָל פְּקֻדָּה וּפְקֻדָּה.
• עומק המחסנית בְּכָל פְּקֻדָּה וּפְקֻדָּה.
• הטיפוס שֶׁל כָּל אחד מהערכים במחסנית בְּכָל פְּקֻדָּה וּפְקֻדָּה.

⌘סוף{ספרור}
הנתונים הידועים למאמת הם הטיפוסים שֶׁל השדות והמתודות (מידע זֶה הרי מצוי בקובץ
הַ- CLASS).

פתרון מערכת המשוואות נעשה בדרך פשוטה: ניחוש פתרון, ותיקונו, תּוֹךְ כְּדֵי מעבר
חוזר ונשנה עַל הגרף שֶׁל הבלוקים הבסיסייים, עד שאין תיקונים נוספים.

נִתָּן להוכיח שהשיטה בה פועל הַמְּאַמֵּת מתכנסת תמיד לפתרון הנכון.

לְאַחַר פתרון מערכת המשוואות, יכול הַמְּאַמֵּת לבדוק שהַ-⌘גאוה Byte Code לֹא יעשה
שגיאות טיפוס כאשר הוּא יבוצע.

כמובן, הקוד אותו פולט הַמְּהַדֵּר אינו מכיל שגיאות טיפוס, אַךְ הַמְּאַמֵּת אינו
מסתפק בכך, ומציב חומת הגנה נוספת בפני קוֹד זדוני, קוֹד אֲשֶׁר לֹא הַמְהַדֵּר
יצר.

שגיאות טיפוס המתגלות בשלב זֶה יגרמו להפסקת ביצוע הַתָּכְנִית.

§אתחול הַמַּחְלָקָה
לְאַחַר הבדיקה המפורטת המתוארת מעלה, עַל טוען הַמַּחְלָקוֹת לאתחל אֶת
הַמַּחְלָקָה, האתחול כולל אֶת יצירת כָּל המשתנים הסטטיים שֶׁל הַמַּחְלָקָה
ואתחולם.

במקרים רבים, האתחול שֶׁל משתנים סטטיים כרוך בביצוע קוֹד, ויתכן שהביצוע שֶׁל קוֹד
זֶה יגרום לטעינתן שֶׁל מחלקות אחרות.

§תרגילים

⌘תחילת{ספרור}

• הסבר מדוע קֹבֶץ הַמַּטָּרָה בִּשְׂפַת ⌘סי גדול הרבה יוֹתֵר מקובץ הַמַּטָּרָה
בִּשְׂפַת ⌘גאוה. בהסברך זה, השתמש במונח טעינה דינמית.

• הסבר מדוע קֹבֶץ הַמַּטָּרָה בִּשְׂפַת ⌘גאוה מכיל הרבה יוֹתֵר מידע טכסטואלי
מאשר קֹבֶץ הַמַּטָּרָה בִּשְׂפַת ⌘סי.

• הדר אֶת הַתָּכְנִית בִּשְׂפַת ⌘סי שכתבנו, אַךְ מבלי לבצע קִשּׁוּר (linking).
הַפְּקֻדָּה לשם כָּךְ הִיא: cc -c hello.c. (משמעות הדגל c- היא הדור בלבד, ללא
קִשּׁוּר.) בדוק אֶת גודל קֹבֶץ התוצאה (hello.o) וְאֶת תכנו (באמצעות הַפְּקֻדָּה strings -a),
והסבר אֶת ממצאיך.

• מדוד (תּוֹךְ שימוש בפקודה time) אֶת זמן ההידור המלא (כולל קִשּׁוּר) שֶׁל
הַתָּכְנִית hello.c. מדוד (באותו אופן) אֶת זמן ההידור נטו (ללא קִשּׁוּר) שֶׁל
הַתָּכְנִית hello.c, השווה לזמן ההידור שֶׁל הַתָּכְנִית Hello.java והסבר אֶת
ממצאיך.

• הסבר את השיקולים מאחורי ההחלטה של מתכנן המהדר להמשיך את החיפוש כאשר קֹבֶץ
הַמָּקוֹר נמצא והודר, ולא להמשיך את החיפוש כאשר רק קֹבֶץ הַמַּטָּרָה נמצא, או
כאשר תאריך קֹבֶץ הַמַּטָּרָה מאוחר לתאריך קֹבֶץ הַמָּקוֹר.

• כתוב מַחְלָקָה X בִּשְׂפַת ⌘גאוה שיש בה מתודה סטטית main המשתמשת במחלקה אחרת
Y. הדר אֶת הַמַּחְלָקָה X מבלי לְהַדֵּר אֶת הַמַּחְלָקָה Y, ובדוק ששתי
הַמַּחְלָקוֹת אכן הודרו.

• כָּעֵת שנה אֶת הַמַּחְלָקָה Y, באופן שֶׁהִיא לֹא תהיה תואמת למחלקה X, והדר
אֶת הַמַּחְלָקָה Y בלבד (שים לב שלא לְהַדֵּר אֶת הַמַּחְלָקָה X). הסבר מדוע
ההידור אינו מייצר הודעות שגיאה.

• כָּעֵת הרץ אֶת הַתָּכְנִית X והסבר אֶת הודעות השגיאה המתקבלות.

• תכנן ובצע ניסוי לבדיקת התנהגות המהדר שֶׁל שפת ⌘גאוה במקרים פתולוגיים בהם אותה
מַחְלָקָה (בין קֹבֶץ הַמָּקוֹר ובין קֹבֶץ הַמַּטָּרָה) מופיעה יוֹתֵר מפעם אחת
ב-CLASSPATH.

• הדר אֶת הַתָּכְנִית הבאה והרץ אותה. הסבר אֶת הפלט המתקבל. בדוק אֶת גדלי קבצי
הַ-CLASS המתקבלים, וְאֶת תכנם.
\bash[script,stdout]
cat << EOF > A.java
public class A {
   private static B b=new B();
   public A() { System.out.println("An object of type A is born!"); }
   public static void main(String[] args) {
     System.out.println("Main called\n");
   }
}
class B {
  public B() { System.out.println("An object of type B is born!"); }
  private static A a=new A();
}
EOF
\END

• חפש באינטרנט מידע עַל הַתָּכְנִית gcj והסבר כיצד הִיא פועלת. מהם היתרונות
  והחסרונות ביחס לארכיטקטורת הַ-JVM.

• הסבר מדוע שם המחלקה הראשית ב-⌘גאוה צריך להיות זהה לשם הקובץ.

• הדר את התכנית הבאה ב-JAVA המכילה מחלקה פנימית. אלו קבצים נוצרים? מה גודלם?
\bash[script,stdout]
cat << EOF > Outer.java
public class Outer {
  public static class Inner {
  }
}
EOF
\END

• מחק כעת את כל הקבצים שנוצרו עלי ידי המהדר, והדר תוך שימוש בדגל verbose את
התכנית הבאה אשר המכילה פניה למחלקה הפנימית לעיל.

\bash[script,stdout]
echo “public class Client extends Outer.Inner { }” > Client.java
\END

 בדוק את הקבצים הנוצרים. כיצד לדעתך מאתר המהדר את המחלקה הפנימית? איך מתגבר
המהדר לדעתך על הבעיה שיתכן כי תוגדר מחלקה Inner בתוך חבילה ששמה Outer? תכנן
ובצע ניסוי לבדיקת השערתך.

• צור את המחלקות הבאות, ובצע את ההידור כמפורט מטה.

\bash[script,stdout,stderr]
rm -f User.java First.java
echo class User extends Second {} > User.java
echo public class First {} class Second{} > First.java
javac -verbose User.java
\END

הסבר את הודעת השגיאה המתקבלת. כעת בצע
\E|javac -verbose First.java|
 וחזור והדר את User.java.
הסבר מדוע ההודעה נעלמה.

⌘סוף{ספרור}
