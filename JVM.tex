יש כמה ענינים מיוחדים בַּהִדּוּר (compilation), בקישור (linking) וּבהרצה (run)
שֶׁל תכניות  \E|Java|:
\ספרר
• הידור לשפת ביניים, ולא לשפת מכונה.
• הידור רקורסיבי.
• קִשּׁוּר דינמי.
• שפת מכונה שֶׁהִיא Strongly Typed
• שילוב שֶׁל Static Typing וְשֶׁל Dynamic Typing
===

בפרק זֶה נדון בענינים אלו.

§ מבוא: הידור והרצה שֶׁל תכנית \E|Java| פשוטה

נכתוב תכנית \E|Java| קצרה. ראשית נכין קובץ ששמו Hello.java.
\bash[script,stdout]
cat << EOF > Hello.java
public class Hello {
  public static void main(final String[] args) {
    System.out.println("Hello, World!\n");
  }
}
EOF
\END
(במה שכתוב מעלה, הסימן ⌘
מציין את הזרז והפקודה cat מעתיקה מהקלט הסטנדרטי
אל הפלט הסטנדרטי. האידיום cat << EOF משמעו ב-bash העתקה מהקלט הסטנדרטי, עד
אשר בקלט תופיע שורה שבה מופיעה המילה EOF לבדה.)1
כעת, נהדר את התכנית:
\bash[script,stdout]
javac Hello.java
\END
(התכנית javac הִיא המהדר שֶׁל שפת \E|Java|).

נבדוק כעת אלו קבצים יש לנו:
\bash[script,stdout]
ls -lsh Hello.*
\END

כלומר, פקודת ההידור תירגמה את קובץ המקור (source file) ששמו Hello.java
לקובץ מטרה (object file) ששמו Hello.class.

ניתן להבחין שקובץ המטרה ארוך מעט מקובץ המקור: בקובץ המטרה יש
418 בתים, בעוד שבקובץ המקור יש יש 119 בתים.

כעת, בכדי להריץ את התכנית יש לכתוב

\bash[script,stdout]
java Hello
\END

ההרצה הזו מפעילה את הקובץ Hello.class, ומבצעת את המתודה הסטטית main שבתוכו.
אמנם הקובץ Hello.class הוּא קובץ בינארי, אַךְ בכל זאת ניתן לבחון את תכנו תּוֹךְ שימוש
באמצעים שונים. כך למשל, התכנית od מציגה את תוכנו שֶׁל קובץ בינארי:

\bash[script,stdout]
od -c Hello.class
\END

עיון בפלט מגלה שהקובץ Hello.class מכיל בתוכו סדריות (strings) טכסט מענינות.
כְּדֵי לגלות מה הן, נֹחַ להשתמש בתכנית strings:
\bash[script,stdout]
strings Hello.class
\END

בהמשך, אעמוד ביתר פירוט על תכנו ומבנהו שֶׁל קובץ ה-CLASS. בשלב זה, נשווה את
הפעולות שביצענו, למה שנדרש כְּדֵי להריץ תכנית בִּשְׂפַת ⌘סי.
ראשית, נכתוב תכנית פשוטה בִּשְׂפַת ⌘סי.
\bash[script,stdout]
cat << EOF > hello.c
#include <stdio.h>
int main() {
   return printf("Hello, World!\n") !=0;
}
EOF
\END
אַחַר, נהדר את התכנית:
\bash[script,stdout]
cc hello.c -o hello
\END

(הדגל o- מודיע למְהַדֵּר היכן לשמור את קובץ המטרה, במקרה זֶה לקובץ ששמו
hello)
כעת, נריץ את התכנית:
\bash[script,stdout]
./hello
\END
נבחן את גדלי הקבצים המעורבים:
\bash[script,stdout]
ls -lsh hello hello.c
\END
נבדוק גַּם את הסדריות שבקובץ המטרה:
\bash[script,stdout]
strings -a hello
\END

\bash[script,stdout]
strip hello
\END

\bash[script,stdout]
strings -a hello
\END

\bash[script,stdout]
ls -ls hello hello.c
\END
נשים לב להבדלים הבאים בין שפת ⌘סי ובין שפת \E|Java|:
\ספרר
• קובץ המטרה בִּשְׂפַת ⌘סי גדול הרבה יוֹתֵר מקובץ המטרה בִּשְׂפַת
|Java|.
• קובץ המטרה בִּשְׂפַת \E|Java| מכיל הרבה יוֹתֵר מידע טכסטואלי מאשר קובץ
המטרה בִּשְׂפַת ⌘סי.
• קובץ המטרה בִּשְׂפַת ⌘סי ניתן להרצה ישירה עַל ידי הפקודה hello/.
. לעומת זאת, יש להשתמש בפקודה מיוחדת כְּדֵי להריץ את קובץ המטרה
בִּשְׂפַת \E|Java|, כלומר, היה עלינו לכתוב java Hello.
הַ-JVM
===

כפי שראינו לעיל, תכניות ב-|Java| אינן מהודרות (Compiled) לשפת המכונה עליה
תופעל התכנית. במקום זאת, התכנית מהודרת לשפה אחרת, שפת מכונה שֶׁל
מכונה וירטואלית. הקובץ Hello.class מכיל, פרט לסדריות הטכסט שגילינו למעלה,
פְּקֻדּוֹת לביצוע עֲבוּר המכונה הזו.

שֵׁם המכונה הזו הוּא הַ-|Java| Virtual Machine ובקיצור הַ-JVM. הַ-JVM אינה
קיימת במציאות כדרך שאתה, הקורא קיים. הִיא אינה תופסת נפח במרחב הפיסי, ואי אפשר
למשש או לרחרח אותה. אבל, הִיא קיימת בכל זאת – בכך שיש לה מפרט מפורט ביותר:
\begin{english}
\url{http://java.sun.com/docs/books/jvms/}
\end{english}

וישנה תכנית מחשב הַמממשת את המפרט הזה. כלומר, ישנה תכנית מחשב הקוראת
את הפקודות שֶׁל הַ-JVM מפענחת אותן, ומבצעת אותן, ממש כשם שישנה מכונה פיסית,
מוחשית, הקוראת את הפקודות שֶׁל הַ-8086 ומבצעת אותן. התכנית הזו נקראת
פעמים רבות גַּם הִיא הַ-JVM.

אפשר לממש את הַ-JVM בִּשְׂפַת ⌘סי, וכך בדרך כלל עושים. ניתן גַּם לממש אותו
בשפות עיליות אחרות או בִּשְׂפַת המכונה (למשל 8086 Assembly). ניתן אפילו לממש
את הַ-JVM בִּשְׂפַת \E|Java|. רקורסיה כזוֹ, בבחינת „צבת בצבת עשוייה“ הִיא מעט
מבלבלת, ונניח לה.

הידור שֶׁל תכנית \E|Java| משמעו תרגום תכנית בִּשְׂפַת ⌘גאוה לתכנית שקולה
לשפה שאותה מכירה מכונת הַ-JVM – לשפה הזו קוראים \E|Java| Byte Code.

ישנו מספר לֹא קטן שֶׁל מימושים ל-JVM. ערך הויקיפדיה
\begin{english}
\url{http://en.wikipedia.org/wiki/Listₒfⱼavaᵥirtualₘachines}
\end{english}

מונה, לעת כתיבת ספר זֶה, כמעט שישים מימושים שונים. המימוש הנפוץ ביותר הוּא ככל
הנראה זֶה שֶׁל חברת Sun.

מימוש שֶׁל הַ-JVM הוּא תלוי מכונה ותלוי מערכת הפעלה. אבל, מהרגע שהותקן במחשב
מסויים מימוש כלשהו שֶׁל הַ-JVM. ניתן להריץ עליו כָּל תכנית הכתובה
בִּשְׂפַת הַ-|Java| Byte Code.

אשר עַל כן, כאשר כתבנו למעלה:

\bash[script,stdout]
java Hello
\END

הרצנו את הַ-JVM (הפקודה java משמעה הפעלת הַ-JVM), והורינו לו להתחיל לבצע
את פְּקֻדּוֹת הַ-|Java| Byte Code אשר בקובץ Hello.class.

ארכיטקטורה זוֹ מאפשרת לכן להריץ תכניות \E|Java| עַל כָּל מחשב, ללא צורך בהתקנה
מיוחדת. בדוגמא שלנו, נוכל לקחת את הקובץ Hello.class ולהעתיק אותו למכונת DOS
למשל, ולהריץ את התכנית שֵׁם בדיוק באותו אופן:

\begin{NONE}
C:\> java Hello
Hello, World!
\end{NONE}

לעומת זאת, אִם נעתיק את הקובץ הבינארי hello שהכנתי מתכנית ⌘סי למכונת DOS לֹא
נוכל להפעילו שֵׁם.

יתרון נוסף שֶׁל האכיטקטורה הוּא שה JVM הוּא "בטוח", במובן זֶה, שבניגוד להרצה
ישירה עַל המכונה, הַ-JVM תוחם את מרחב הפעולה שֶׁל תכניות המופעלות עליו –
ויכול למנוע מהן לבצע פעולות שאינן מותרות להן, כמו גישה לכתובות זיכרון לֹא
חוקיות. הארכיטקטורה מאפשרת עַל כן להפעיל תכניות מחשב המגיעות ממקור לֹא
מוכר (אתר כלשהו באינטרנט), ולהריצן ב"ארגז החול" (Sand box) שֶׁל הַ-JVM, כאשר
התכנית, כָּל כמה שתנסה, אינה יכולה לצאת מהארגז.

בדוגמא שלנו, אפילו אִם היינו משנים באמצעים חיצוניים את הקובץ Hello.class לֹא
היינו יכולים, עד כמה שננסה להיות זדוניים, לגרום להרצה שֶׁל הקובץ
\begin{NONE}
C:\> java Hello
\end{NONE}

לקרוא כתובות בזיכרון המחשב, שאסור לה לקרוא, או גרוע מכך, לכתוב לכתובות בזיכרון
שאסור לכתוב אליהן.

החיסרון העיקרי שֶׁל ארכיטקטורה הַ-JVM הוּא ביצועים ירודים. ביצוע שֶׁל תכנית
|Java| עַל מכונה וירטואלית עלול להיות אלפי מונים איטי יוֹתֵר מביצוע שֶׁל
תכנית שקולה בשפה אחרת, המהודרת לביצוע ישירות עַל המכונה הפיזית. עַל חיסרון
זֶה מתגברים באמצעות טכנולוגיות שונות, שהחשובה בהן הִיא הַ- Just In Time
compiler, הידוע לעיתים גַּם בשם הקצר JIT Compiler או סתם JIT.

הַ-JIT הוּא מרכיב שֶׁל מימוש שֶׁל הַ-JVM, אשר מזהה קטעים בתכנית המתבצעת
אשר מתבצעים שוב ושוב, ומתרגם אותם, תּוֹךְ כְּדֵי ריצה לשפת המכונה הפיזית, מה
שמביא לשיפור עצום במהירות הביצוע.

נבדוק את זמן הריצה שֶׁל תכנית הַ-|Java| שכתבנו,
\bash[verbose,script,stdout,stderr]
/usr/bin/time java Hello
\END

נבדוק כעת את זמן הריצה שֶׁל תכנית הַ-⌘סי המקבילה:

\bash[script,stdout,stderr]
time ./hello
\END

בקירוב, אנו מקבלים שתכנית הַ-⌘סי רצה יוֹתֵר מפי 300 מהר יוֹתֵר מתכנית הַ-|Java|.
אבל, ההבדל אותו מדדנו כאן, אינו נובע כולו מזמני הביצוע שֶׁל תכנית הַ-|Java|
הקצרה כל כך שלנו, אלא מהעובדה, שכדי להפעיל תכנית \E|Java| יש לאתחל את
הַ-JVM. נבדוק למשל את זמן הריצה שֶׁל תכנית \E|Java| אשר אינה קיימת:

\bash[script,stdout,stderr]
/usr/bin/time java NoSuchClass
\END

אנו רואים שזמן הריצה בעֲבוּר מחלקה שאינה קיימת, הוא 326 מילישניות, לעומת 344
מילישניות בעֲבוּר המחלקה Hello.

למרות השם, אֵין לשפת \E|Java| בעלות עַל שפת הַ-⌘גאוה Byte Code. מסתבר שיתרון הזמינות
(עַל מחשבים רבים ושונים) כמו גַּם יתרון היבילות (Portability) שֶׁל הקוד המהודר
ושיקולים אחרים מביאים לתוצאה ששפות אחרות גַּם הן מהודרות לשפה זוֹ .

רשימה חלקית שֶׁל שפות הניתנות להידור לשפת ה-JVM מופיעה כאן:

\begin{english}
\url{http://en.wikipedia.org/wiki/Listₒf_JVMₗanguages}
\end{english}

§הידור תכניות \E|Java|

תכנית \E|Java| מורכבת מקבצים, כאשר בכל קובץ נמצאת הגדרה שֶׁל מחלקה
(Class)
 אחת ראשית שֶׁשְּׁמָהּ זהה לשם הקובץ,
ולעיתים הגדרה שֶׁל מַחְלְקוֹת
משנה: בדרך כלל מחלקות המשנה הינן מחלקות מקוננות במחלקה הראשית, ולעיתים גַּם
הגדרה שֶׁל מחלקות אחרות, מחלקות משניות, שאינן מקוננות במחלקה הראשית. השימוש
במחלקות משניות הוּא נדיר.

גַּם בתוך המחלקות המשניות ניתן להגדיר מחלקות מקוננות, אַךְ השימוש בכך
נדיר ביותר.

בדרך כלל, מספיק להדר רק קובץ אחד, הקובץ המכיל את המחלקה שבה מתחיל
הביצוע שֶׁל התכנית, וזאת, אפילו אִם התכנית משתמשת במחלקות רבות אחרות.
הידור הקובץ הזה, יגרום למְהַדֵּר לחפש את כָּל המחלקות האחרות שבהן
עושה שימוש המחלקה הזו, ולהדר אותן במידת הצורך.

כְּדֵי שהַמְּהַדֵּר שֶׁל \E|Java| יוכל לבצע חיפוש זֶה, הוּא חייב לדעת היכן יש לבצע
את החיפוש. נזכר בארגון שֶׁל המחלקות בשפה. כָּל מחלקה ב-|Java| מצוייה
בחבילה (Package), כאשר כָּל חבילה מהווה מרחב שמות אחד, והחבילות כולן מאורגנות
במבנה שֶׁל עץ. כך למשל תכניות שנכתבות בפקולטה למדעי המחשב בתכניון,
צריכות להמצא בחבילה אשר שמה הוּא

il.ac.technion.cs

כלומר, בחבילה שֶׁשְּׁמָהּ הוּא cs המצוייה בחבילה שֶׁשְּׁמָהּ הוּא technion
המצוייה בחבילה שֶׁשְּׁמָהּ הוּא ac המצוייה בחבילה שֶׁשְּׁמָהּ הוּא il. נשים לב
ששמות החבילות בם בחרנו מצייתים למוסכמה שֶׁל שפת \E|Java| לפיה, שֵׁם החבילה מתחיל
בכתובת הַ-domain שֶׁל הארגון אשר כתב אותה, כאשר מרכיבי הכתובת נמצאים בסדר
הפוך.

כמובן, אֵין מניעה להקים חבילות נוספות בתוך החבילה il.ac.technion.cs. כך למשל,
מחלקות האחראיות עַל ביצוע משימה שֶׁל טיפול בסדריות (strings) ואשר פותחו בפקולטה
יכולות למשל להמצא בחבילה

il.ac.technion.cs.strings

ישנו מיפוי היררכי שֶׁל מבנה העץ שֶׁל החבילות לתת-עץ שֶׁל מערכת הקבצים. כָּל
המחלקות השייכות לחבילה

 il.ac.technion.cs.strings

ימצאו עַל כן בתיקיה שֶׁשְּׁמָהּ הוּא:

/Ã/ac/technion/cs/strings

כאשר הסימן Ã מציין את המקום שבו מתחיל תת העץ שֶׁל מערכת הקבצים עליו מאוחסנות
התכניות.

נסתכל למשל עַל מחלקה שֶׁשְּׁמָהּ הוּא StringParser המוגדרת בחבילה
שֶׁשְּׁמָהּ הוּא

 il.ac.technion.cs.strings

כלומר מחלקה שֶׁשְּׁמָהּ המלא

il.ac.technion.cs.strings.StringParser

אזי, אִם למשל בחרנו למפות את עץ החבילות לתיקיה

 /home/yogi/java

הרי המחלקה תמצא בקובץ ששמו הוּא

/home/yogi/java/ac/technion/cs/strings/StringParser.java

יתירה מכך, אִם המחלקה הודרה כבר ל-|Java| Byte Code הרי תוצאת ההידור תשמר
בקובץ בעל שֵׁם זהה, אלא שהסיומת שלו תהיה class. בדרך כלל קובץ זֶה ימצא באותו
מקום שבו נמצא קובץ המקור, כלומר שֵׁם הקובץ המהודר המלא יהיה:

/home/yogi/java/ac/technion/cs/strings/StringParser.class

כְּדֵי לאתר את הקובץ, המהדר חייב לקבל את מיקום נקודת העיגון - שֵׁם
התיקיה במערכת הקבצים ממנו מתחיל המיפוי. בדרך כלל, המיפוי שֶׁל עץ המחלקות
הוּא בו זמנית למספר מקומות, שיכולים לכלול נקודות שונות בהיררכיית מערכת הקבצים,
שמות שֶׁל קבצי ארכיב (קבצים בעלי סיומתzip או סיומת jar) המכילים בתוכם, בפורמט
דחוס, עצים שלמים, וכן גַּם כתובות URL המכילות בתוכן את המחלקות לביצוע.

רשימת המקומות בהם יש לחפש מחלקות נודעת בשם CLASSPATH. נניח שערכו שֶׁל
הַ-CLASSPATH הוּא הרשימה בת שתי התיקיות:

1. /home/yogi/java
2. /home/yogi/import/lib

נניח גַּם שהמחלקה StringParserDemo (אשר קוֹד המקור שלה מצוי בקובץ
StringParserDemo.java) עושה שימוש במחלקה אשר שמה המלא הוּא
il.ac.technion.cs.strings.StringParser

כְּדֵי להדר את StringParserDemo, יש ראשית לקבוע את הַ-CLASSPATH. הקביעה
נעשית עַל ידי יצוא משתנה סביבה (environment variable). לדוגמא ב-bash נכתוב

export CLASSPATH=/home/yogi/java:/home/yogi/import/lib

ולאחר מכן להפעיל את פקודת ההידור הבאה:

javac StringParserDemo.java

ניתן גַּם להעביר את ה-CLASSPATH כפרמטר למהדר, בפקודה שבה אנו מפעילים אותו:

javac -classpath /home/yogi/java:/home/yogi/import/lib StringParserDemo.java

אַךְ שיטה זוֹ יעילה פחות, שכן בדרך כלל, נשתמש בקביעה שֶׁל ה-CLASSPATH לתכניות
נוספות (למשל java) ולהרצות רבות שֶׁל המהדר.

בין כך ובין כך, המהדר יהדר את הקובץ הנתון, וייצר קובץ המכיל את
הפקודות המתאימות בִּשְׂפַת הַ-|Java| ByteCode. התוצאה תימצא בְּקֹבֶץ אשר שמו
StringParserDemo.class אולם, יחד עִם זאת, המהדר יוודא שגם המחלקה

 il.ac.technion.cs.strings.StringParser

קיימת ומהודרת. לשם כך, הוּא יחפש ראשית בתיקיה

/home/yogi/java/ac/technion/cs/strings/

ואח"כ-בתיקיה:

/home/yogi/import/lib/ac/technion/cs/strings/

החיפוש יכול להביא לאחת מבין שלוש תוצאות:

\ספרר

• מציאת קובץ מקור. אִם באחת משתי התיקיות המהדר מוצא את הקובץ
StringParser.java אז המהדר בודק אִם גַּם הקובץ StringParser.class נמצא
שֵׁם.

אִם הקובץ StringParser.class לֹא נמצא, או שהתאריך שלו מוקדם לתאריך שֶׁל קובץ
המטרה הצמוד אליו, StringParser.class אז המהדר יהדר את הקובץ
StringParser.java כְּדֵי ליצר את StringParser.class באותה תיקיה.

הסבר: אִם הקובץ StringParser.class לא קיים, ברור שיש צורך להדר את הקובץ את
StringParser.java כדי ליצר אותו. אִם StringParser.class קיים, אך התאריך שלו
מוקדם לתאריך של הקובץ StringParser.java, נראה שקובץ המקור StringParser.java
השתנה לְאַחַר שהודר, ועל כן יש להדרו שוב.

• מציאת קובץ מטרה, ללא קובץ מקור. אִם הקובץ StringParser.java לֹא נמצא באף
אחת משתי התיקיות, ובאחת מהתיקיות נמצא הקובץ StringParser.class אז המהדר
ממשיך הלאה.

• העדר קובץ מטרה וקובץ מקור. אִם לֹא StringParser.java ולא StringParser.class
מצויים באף לֹא אחת מהתיקיות, המהדר מודיע הודעת שגיאה ועוצר.
===

פעולת החיפוש וההידור עַל פי הצורך נמשכת עד אשר כָּל המחלקות בהן משתמשת
המחלקה המקורית, אִם באורח ישיר, ואם באורח עקיף, מהודרות. (אִם המהדר מאתר
רק את קובץ המטרה שֶׁל מחלקה מסויימת, הוא אינו מחפש את המחלקות
שבהן מחלקה זוֹ משתמשת.)

לְאַחַר שהַמְּהַדֵּר איתר (או יצר) את הקובץ StringParser.class הוּא מחלץ
ממנו את רשימת כָּל המתודות המוגדרות במחלקה, ורשימת כָּל המשתנים המוגדרים
במחלקה, ובודק שהשימוש שֶׁל המחלקה StringParserDemo במחלקה StringParser היה
נכון מבחינת הטיפוסים, כלומר שהפרמטרים למתודות שֶׁל StringParser היו בדיוק לפי
הטיפוסים המוכרזים במחלקה StringParser, שטיפוס ערך החזרה שֶׁל המתודות הוּא בדיוק
לפי מה שהוגדר במחלקה, וכל מה שצריך לבדוק כְּדֵי לבצע בדיקה מלאה שֶׁל Static
Typing.

(כרגיל, התהליך המלא מכיל פרטים רבים נוספים. כך למשל, ניתן להגדיר CLASSPATH
נפרד עֲבוּר קבצי \E|Java| וְ CLASSAPTH נפרד עֲבוּר קבצים המכילים ⌘גאוה ByteCode,
והתהליך אף מורכב יוֹתֵר בעֲבוּר קבצים המכילים מספר מחלקות.)

הידור תכניות \E|Java| אפשרי גַּם כאשר יש תלות מעגלית. טלו למשל מחלקה A
התלוייה במחלקה B כאשר המחלקה B תלוייה מצידה במחלקה A. אז בהידור שֶׁל
המחלקה A, המהדר יוצר מהמחלקה A קובץ A.class תּוֹךְ הנחה שהמחלקה B
נכונה, ומהמחלקה B קובץ B.class מתוך הנחה שהמחלקה A נכונה. לְאַחַר מכן,
המהדר בודק שהקובץ A.class הוּא עקבי עִם הקובץ B.class ולהפך.

אנו רואים שתהליך ההידור שֶׁל מחלקה ב-|Java| עשוי להיות כרוך בבדיקת טיפוסים
שֶׁל כל המחלקות בהן היא משתמשת.

כְּדֵי להבין את תהליך ההידור הרקורסיבי טוב יוֹתֵר, ניצור שלוש מחלקות קצרות
ביותר: המחלקה A1, המחלקה A2 והמחלקה A3, כאשר המחלקה A1 משתמשת
במחלקה A2, וזוֹ משתמשת במחלקה A3.

\bash[script,stdout]
rm -f A[1-3].java
echo "public class A1 { public A1() { new A2(); }}" > A1.java
echo "public class A2 { public A2() { new A3(); }}" > A2.java
echo "public class A3 { }" > A3.java
\END

ארבעת הפקודות המשורשרות לעיל יוצרות שלושה קבצים, ששמותיהם מתאימים לשלושת
המחלקות. הַבַּנַּאי של המחלקה A1 יוצר עצם מהמחלקה A2, והבנאי של
המחלקה A2 יוצר עצם מהמחלקה A3. המחלקה A3 היא ריקה. (הפקודה הראשונה
מוחקת את הקבצים אם היו קיימים לפני כן.)
כעת נהדר את המחלקה A1, ונבקש מהמהדר לדווח על מעשיו:
\bash[script,stdout,stderr]
javac -verbose A1.java
\END

נשים לב שהמהדר מחפש קבצי class בשורה ארוכה שֶׁל מקומות ובהם קבצי הארכיב הבאים:
resources.jar, rt.jar, sunrsasign.jar, jsse.jar,jce.jar, charsets.jar, netx.jar,
plugin.jar, rhino.jar המצויים כולם בתיקיה

/usr/lib/jvm/java-6-openjdk/jre/lib/

וכן בקובץ הארכיב jdk.boot.jar המצוי בתיקיה

/usr/lib/jvm/java-6-openjdk/jre/lib/modules/

וכמו כן, גם בתיקיה

/usr/lib/jvm/java-6-openjdk/jre/classes

ועוד במקומות רבים ושונים. באחד מבין המקומות הללו המהדר מוצא את המחלקה
java.lang.Object (ממנה יורשות כל המחלקות ב-|Java|, ובפרט גַּם המחלקה
A1). נשים לב לכך שהמהדר אינו מחפש מחלקות אחרות שבהן עושה שימוש המחלקה
java.lang.Object.

כְּדֵי להדר את המחלקה A1 יש לאתר את המחלקה A2. הַ-CLASSPATH
במקרה שלנו הוא ריק, ולכן המהדר מחפש את המחלקה A2 בתיקיה הנוכחית, וכיוון
שהוא מוצא שֵׁם את הקובץ A2.java הוא מהדר אותו, תּוֹךְ שהוא מודיע:

[checking A1]
[loading ./A2.java]
[parsing started ./A2.java]
[parsing completed 0ms]
[wrote A1.class]

אבל, הפעולה אינה שלמה, שכן כְּדֵי להדר את המחלקה A2 המהדר צריך גַּם
לאתר ולהדר את המחלקה A3 שבה עושה שימוש המחלקה A2. הודעות המהדר הן:

[checking A2]
[loading ./A3.java]
[parsing started ./A3.java]
[parsing completed 1ms]
[wrote ./A2.class]

השלב האחרון הוא ההידור שֶׁל המחלקה A3, אשר אינה עושה שימוש במחלקות
אחרות. הודעות המהדר הן על כן מועטות בעֲבוּר מחלקה זוֹ :

[checking A3]
[wrote ./A3.class]

מה יקרה אִם ננסה להדר את המחלקה A1 פעם נוספת, מבלי לשנות אף אחת
מהמחלקות?

\bash[script,stdout,stderr]
javac -verbose A1.java
\END

כפי שרואים לעיל, המהדר מהדר את המחלקה A1, ולשם כך הוא מאתר את הקובץ
A2.class וכיוון שקובץ זה מעודכן יוֹתֵר מהקובץ A2.java, המהדר אינו טורח לבדוק את
המחלקה A3.
§ מבנה קובץ CLASS

כפי שראינו, בְּקֹבֶץ CLASS יש מידע מספיק המאפשר לבדוק את הטיפוס שֶׁל כָּל
תכנית המשתמשת בו. בכל קובץ כזה ישנם שלושה חלקים עיקריים:

\ספרר
• כותרת Header: מספר קטן שֶׁל בתים, המזהה את הקובץ.
• טבלאות Pool: המכילות את רשימת כָּל הסדריות בהן משתמשת המחלקה, רשימת
כָּל המחלקות האחרות בהן משתמשת המחלקה, רשימת המתודות בהן משתמשת
המחלקה, וכן את רשימת המתודות והמשתנים המוגדרים במחלקה.
• Byte code: הפקודות בִּשְׂפַת הַ-|Java| Byte Code שיש בגוף המתודות.
===

במאמץ לֹא גדול ניתן לזהות מקצת ממרכיבים אלו בפלט שֶׁל סקירת הקובץ
%\bash[script,stdout]
Hello.class:

<init>
Code
LineNumberTable
main שֵׁם המתודה היחידה במחלקה זוֹ
([Ljava/lang/String;)V טיפוס הארגומנט למתודה זוֹ, מערך שֶׁל
סדריות
SourceFile
Hello.java
Hello, World! המחרוזת אותה תדפיס התכנית
Hello
java/lang/Object המחלקה ממנה יורשת
המחלקה הזו
java/lang/System מחלקה בה משתמשת המחלקה
הזו
Ljava/io/PrintStream; עוד מחלקה בה משתמשת המחלקה
הזו
java/io/PrintStream אזכור נוסף שֶׁל מחלקה בה משתמשת
המחלקה הזו
println שֵׁם שֶׁל מתודה לה קוראת מתודה במחלקה זוֹ
(Ljava/lang/String;)V עוד מחלקה בה משתמשת המחלקה
הזו
%\END

כדאי לדעת כי בקובץ ה-CLASS המילה <init> מציינת את השם של הַבַּנַּאי
(Constructor) של המחלקה.
בכל זאת, הפענוח אינו קל. ישנן תכניות רבות המדפיסות את התוכן שֶׁל קבצי
CLASS באופן הקריא לבני תמותה. הנה פלט שֶׁל אחת מהן. בתוך הפלט, הוספתי, בשפה
העברית ובכתב יד, מעט הסברים.
%\bash[script,stdout]
%jcf-dump Hello.class
%\END

ניתן להשתמש גַּם ב- jcf-dump בכדי לראות את הַ-Byte Codes שֶׁל שתי המתודות
(מודגש בפלט הבא):

%\bash[script,stdout]
%jcf-dump Hello.class
%\END

אנו רואים שבקובץ הַ-CLASS יש מידע מספיק כְּדֵי לזהות את הטיפוס המלא שֶׁל כָּל
המתודות, ולכן אפשר להשתמש בקובץ כְּדֵי לבדוק אִם השימוש היה תקין. למעשה, ניתן
בקלות לשחזר את ה"חתימה" שֶׁל המחלקה המקורית מקובץ הַ-CLASS (החתימה
מוגדרת, באורח לֹא פורמלי, כקוד המקורי, במחיקת ההערות והפקודות לביצוע):

\bash[script,stdout]
javap Hello
\END

הרצה שֶׁל תכניות \E|Java|
כאמור, הרצה שֶׁל הפקודה java הִיא הפעלה שֶׁל הַ-JVM. הַ-JVM הינו
תכנית שבמרכזה מנוע (engine) המבצע את מחזוֹר הפעולות הרגיל שמבצעת יחידת
העיבוד המרכזית (CPU) במכונה פיזית:
\ספרר
• קידום הַ-Program Counter
• איחזור הפקודה הבאה
• פענוח הפקודה
• ביצוע הפקודה
===
כאשר משתנים בתוך המנוע שֶׁל הJVM מדמים את האוגרים (Registers) שֶׁל המכונה
הוירטואלית, מערכים בתוכו מדמים את מרחב הזיכרון, ועוד.
ישנם חלקים נוספים מלבד המנוע בתוך הַ-JVM. החשוב שבין אלו הוּא טוען המחלקות
(Class Loader). בכל עת שהביצוע שֶׁל המנוע מגיע לפקודה שבה יש גישה למחלקה
אחרת, אִם למתודה ואם לשדה, נכנס לפעולה טוען המחלקות, ומוודא שהמחלקה
המבוקשת טעונה.
נזכר בַּ-Byte Code שֶׁל המתודה main במחלקה Hello שראינו למעלה:

  0: getstatic <Field java.lang.System.out java.io.PrintStream>
הפקודה לעיל מבקשת לאחזר את השדה הסטטי out שבמחלקה java.lang.System עַל כן,
טוען המחלקות יכנס לפעולה, ויוודא שהמחלקה java.lang.System טעונה. מכיוון
שהטיפוס של שדה זו הוא java.io.PrintStream

הפקודה לעיל מבקשת לקרוא למתודה הוירטאולית println (המקבלת כפרמטר String
והמחזירה void) אשר במחלקה java.io.PrintStream, ועל כן, טוען המחלקות
יכנס טרם ביצוע הפקודה לפעולה, ויבדוק שהמחלקה java.io.PrintStream אכן טעונה.

לטוען המחלקות יש טבלא גדולה שבה יש רשימה שֶׁל כָּל המחלקות
אשר נטענו כבר. אִם המחלקה מצוייה בטבלא, הביצוע שֶׁל המנוע ממשיך כרגיל.

אַךְ, אִם המחלקה המבוקשת אינה מצוייה בטבלת המחלקות הטעונות, שומה עַל
טוען המחלקות להשתמש ב-CLASSPATH כְּדֵי לאתר את קובץ הַ-CLASS שֶׁל
המחלקה אותה הוּא מבקש.

שיטה זוֹ, שֶׁל טעינת קוֹד לביצוע בזמן ריצה קרוייה Dynaminc Loading. היתרון שֶׁל השיטה
הוּא בכך שאין צורך לטעון חלקי תכנית שאולי לֹא יבוצעו. החסרון הוּא שיתכן כי בזמן
ריצה יתגלה שהחלקים הנדרשים חסרים, או שאינם תקינים.

טעינת המחלקה דורשת איתור שֶׁל הקובץ, קריאתו, בדיקתו, ואתחול המחלקה. לְאַחַר שאותר
הקובץ קורא אותו טוען המחלקות, ובודק אותו דקדוקית וטכנית. אחרי הבדיקה הדקדוקית
טכנית, מתבצעת בדיקה שֶׁל טיפוסים: הטוען בודק שהטיפוסים המוגדרים בקובץ תואמים את
השימוש בקובץ.

נשים לב לכך שבדיקה זוֹ הִיא בנוסף לבדיקה שהתבצעה בזמן הידור, והיא מיועדת להגנה
בפני טעויות וזדון: מקרים שבהם השתנה קובץ הַ-CLASS לְאַחַר ההידור.

שגיאות המתגלות בשלב זֶה תגרומנה להפסקת ביצוע התכנית.

§ הַמְּאַמֵּת

הבדיקה שֶׁל קובץ הַ-CLASS אינה מתמצית בבדיקה הטכנית הדקדוקית. שפת הַ-|Java| Byte
Code הִיא Strongly Typed בכך שלא יתכן כי תופעל פעולה שאינה מתאימה לטיפוס שֶׁל
ערך מסויים. יחד עִם זאת, אֵין בְּקֹבֶץ הַ-CLASS מידע לגבי הטיפוס שֶׁל כָּל אוגר
ואוגר.

בתוך טוען המחלקות ישנו מרכיב חשוב, הַמְּאַמֵּת, הידוע גַּם בשם Byte Code
Verifier, אשר תפקידו לבדוק שהַ-Byte Code אינו מבצע שגיאת טיפוס. הַמְּאַמֵּת
נכנס לפעולה עִם טעינת המחלקה לזכרון, ופעולתו מבוססת עַל השלבים הבאים:

\ספרר
• חלוקת הקוד לביצוע לבלוקים בסיסיים. בלוק בסיסי הוּא סדרה שֶׁל פְּקֻדּוֹת
מכונה רצופות המתבצעות תמיד יחד. אֵין פקודת קפיצה (goto) אל תּוֹךְ הבלוק,
ואין פקודת קפיצה מתוך הבלוק. הפקודה האחרונה בבלוק בסיסי תהיה עַל כן
תמיד פְּקֻדָּה המשנה את הסדר הרגיל שֶׁל הביצוע: פקודת קפיצה בלתי מותנית
(simple goto), פקודת קפיצה מותנית (conditional goto) פקודת חזרה
(return) וכו'.

• בנית גרף המעברים האפשריים בין הבלוקים הבסיסיים. שני בלוקים יחוברו בקשת מכוונת
בגרף זֶה, אִם יתכן שהם יבוצעו ברציפות.

• איתור האוגרים שבהם נעשה שימוש בכל בלוק בסיסי.

• איתור פְּקֻדּוֹת המחסנית שבכל בלוק בסיסי

===

לְאַחַר מכן, מנסה הַמְּאַמֵּת לפתור מערכת משוואות, שבה הנעלמים הם:

\ספרר
• הטיפוסים שֶׁל כָּל הערכים השמורים באוגרים בכל פְּקֻדָּה וּפְקֻדָּה.
• עומק המחסנית בכל פְּקֻדָּה וּפְקֻדָּה.
• הטיפוס שֶׁל כָּל אחד מהערכים במחסנית בכל פְּקֻדָּה וּפְקֻדָּה.

===
הנתונים הידועים למאמת הם הטיפוסים שֶׁל השדות והמתודות (מידע זֶה הרי מצוי בקובץ
הַ- CLASS).

פתרון מערכת המשוואות נעשה בדרך פשוטה: ניחוש פתרון, ותיקונו, תּוֹךְ כְּדֵי מעבר
חוזר ונשנה עַל הגרף שֶׁל הבלוקים הבסיסייים, עד שאין תיקונים נוספים.

ניתן להוכיח שהשיטה בה פועל הַמְּאַמֵּת מתכנסת תמיד לפתרון הנכון.

לְאַחַר פתרון מערכת המשוואות, יכול הַמְּאַמֵּת לבדוק שהַ-|Java| Byte Code לֹא יעשה
שגיאות טיפוס כאשר הוּא יבוצע.

כמובן, הקוד אותו פולט המהדר אינו מכיל שגיאות טיפוס, אַךְ הַמְּאַמֵּת אינו
מסתפק בכך, ומציב חומת הגנה נוספת בפני קוֹד זדוני, קוֹד אשר לֹא הַמְהַדֵּר
יצר.

שגיאות טיפוס המתגלות בשלב זֶה יגרמו להפסקת ביצוע התכנית.

§אתחול המחלקה
לְאַחַר הבדיקה המפורטת המתוארת מעלה, עַל טוען המחלקות לאתחל את
המחלקה, האתחול כולל את יצירת כָּל המשתנים הסטטיים שֶׁל המחלקה
ואתחולם.

במקרים רבים, האתחול שֶׁל משתנים סטטיים כרוך בביצוע קוֹד, ויתכן שהביצוע שֶׁל קוֹד
זֶה יגרום לטעינתן שֶׁל מחלקות אחרות.

§תרגילים

\begin{enumerate}

• הסבר מדוע קובץ המטרה בִּשְׂפַת ⌘סי גדול הרבה יוֹתֵר מקובץ המטרה
בִּשְׂפַת \E|Java|. בהסברך זה, השתמש במונח טעינה דינמית.

• הסבר מדוע קובץ המטרה בִּשְׂפַת \E|Java| מכיל הרבה יוֹתֵר מידע טכסטואלי
מאשר קובץ המטרה בִּשְׂפַת ⌘סי.

• הדר את התכנית בִּשְׂפַת ⌘סי שכתבנו, אַךְ מבלי לבצע קִשּׁוּר (linking).
הפקודה לשם כך הִיא: cc -c hello.c. (משמעות הדגל c- היא הדור בלבד, ללא
קִשּׁוּר.) בדוק את גודל קובץ התוצאה (hello.o) וְאֶת תכנו (באמצעות הפקודה strings -a),
והסבר את ממצאיך.

• מדוד (תּוֹךְ שימוש בפקודה time) את זמן ההידור המלא (כולל קִשּׁוּר) שֶׁל
התכנית hello.c. מדוד (באותו אופן) את זמן ההידור נטו (ללא קִשּׁוּר) שֶׁל
התכנית hello.c, השווה לזמן ההידור שֶׁל התכנית Hello.java והסבר את
ממצאיך.

• הסבר את השיקולים מאחורי ההחלטה של מתכנן המהדר להמשיך את החיפוש כאשר קובץ
המקור נמצא והודר, ולא להמשיך את החיפוש כאשר רק קובץ המטרה נמצא, או
כאשר תאריך קובץ המטרה מאוחר לתאריך קובץ המקור.

• כתוב מחלקה X בִּשְׂפַת \E|Java| שיש בה מתודה סטטית main המשתמשת במחלקה אחרת
Y. הדר את המחלקה X מבלי להדר את המחלקה Y, ובדוק ששתי
המחלקות אכן הודרו.

• כעת שנה את המחלקה Y, באופן שֶׁהִיא לֹא תהיה תואמת למחלקה X, והדר
את המחלקה Y בלבד (שים לב שלא להדר את המחלקה X). הסבר מדוע
ההידור אינו מייצר הודעות שגיאה.

• כעת הרץ את התכנית X והסבר את הודעות השגיאה המתקבלות.

• תכנן ובצע ניסוי לבדיקת התנהגות המהדר שֶׁל שפת \E|Java| במקרים פתולוגיים בהם אותה
מחלקה (בין קובץ המקור ובין קובץ המטרה) מופיעה יוֹתֵר מפעם אחת
ב-CLASSPATH.

• הדר את התכנית הבאה והרץ אותה. הסבר את הפלט המתקבל. בדוק את גדלי קבצי
הַ-CLASS המתקבלים, וְאֶת תכנם.
\bash[script,stdout]
cat << EOF > A.java
public class A {
   private static B b=new B();
   public A() { System.out.println("An object of type A is born!"); }
   public static void main(String[] args) {
     System.out.println("Main called\n");
   }
}
class B {
  public B() { System.out.println("An object of type B is born!"); }
  private static A a=new A();
}
EOF
\END

• חפש באינטרנט מידע עַל התכנית gcj והסבר כיצד הִיא פועלת. מהם היתרונות
  והחסרונות ביחס לארכיטקטורת הַ-JVM.

• הסבר מדוע שם המחלקה הראשית ב-|Java| צריך להיות זהה לשם הקובץ.

• הדר את התכנית הבאה ב-JAVA המכילה מחלקה פנימית. אלו קבצים נוצרים? מה גודלם?
\bash[script,stdout]
cat << EOF > Outer.java
public class Outer {
  public static class Inner {
  }
}
EOF
\END

• מחק כעת את כל הקבצים שנוצרו עלי ידי המהדר, והדר תוך שימוש בדגל verbose את
התכנית הבאה אשר המכילה פניה למחלקה הפנימית לעיל.

\bash[script,stdout]
echo “public class Client extends Outer.Inner { }” > Client.java
\END

 בדוק את הקבצים הנוצרים. כיצד לדעתך מאתר המהדר את המחלקה הפנימית? איך מתגבר
המהדר לדעתך על הבעיה שיתכן כי תוגדר מחלקה Inner בתוך חבילה ששמה Outer? תכנן
ובצע ניסוי לבדיקת השערתך.

• צור את המחלקות הבאות, ובצע את ההידור כמפורט מטה.

\bash[script,stdout,stderr]
rm -f User.java First.java
echo class User extends Second {} > User.java
echo public class First {} class Second{} > First.java
javac -verbose User.java
\END

הסבר את הודעת השגיאה המתקבלת. כעת בצע
\E|javac -verbose First.java|
 וחזור והדר את User.java.
הסבר מדוע ההודעה נעלמה.

\end{enumerate}
