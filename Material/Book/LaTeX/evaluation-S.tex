
§§ שלושת פעולות היסוד על~$𝓢$
על ה\ע|חוג החילופי| \E|(abelian ring)|~$ℤ$ של המספרים השלמים \E|(the ring~$ℤ$
of integers)| מוגדרות שלוש פעולות יסודיות: שתי הפעולות הבינאריות של הכפל
והחיבור, והפעולה האונארית של מציאת ההופכי החיבורי. 

על הקבוצה~$𝓢$ של ביטויי~\E|S| מעל אלאפאבית כלשהו, נגדיר שלוש פעולות יסודיות:
\begin{enumerate}
  ✦ פעולה בינארית אחת,~$p$ המצרפת ל-\E|dotted pair| שני ביטוים של~$𝓢$,
  \begin{equation}
    p(s₁,s₂)=⌘(s₁⌘.s₂⌘),
  \end{equation}
  ✦ שתי הפעולות האונאריות ההופכיות ל-$p$:
  \begin{enumerate}
    ✦ הפעולה~$p₁^{-1}$ המחזירה את המרכיב הראשון של ביטוי מורכב ב-$𝓢$
    \begin{equation}\label{eq:p1}
      p₁^{-1}(s)=\begin{cases}
        s₁ & ∃ s₂, s₁ ∙ s₂=⌘(s₁⌘.s₂⌘) ⏎
        ⊥  & \textit{otherwise}.
      \end{cases}
    \end{equation}
    ✦ והפעולה~$p₂^{-1}$ המחזירה את המרכיב השני של ביטוי כזה,
    \begin{equation}\label{eq:p2}
      p₂^{-1}(s)=\begin{cases}
        s₂ & ∃ s₁, s₁ ∙ s₂=⌘(s₁⌘.s₂⌘) ⏎
        ⊥  & \textit{otherwise}.
      \end{cases}
    \end{equation}
  \end{enumerate}
\end{enumerate}
הסימן~$⊥$ (אותו יש לבטא \E|bottom|) המופיע ב-\פנה|eq:p1| וב-\פנה|eq:p2|
מציין שערך הפונקציות~$p₁^{-1}$ ו-$p₂^{-1}$ אינו מוגדר כאשר הארגומנט שלהן הוא
איבר אטומי של~$𝓢$, ובכתיב מתימטי
\begin{equation}
  \begin{split}
    p&:𝓢×𝓢→𝓢⏎
    p₁^{-1}&:𝓢 ⇸𝓢⏎
    p₂^{-1}&:𝓢 ⇸𝓢.
  \end{split}
\end{equation}
כלומר,~$p$ היא פונקציה שהתחום הוא זוג של ביטויי~\E|S| והטווח שלה הוא ביטוי כזה.
הפונקציה~$p$ היא גם פונקציה \ע|מלאה|, בכך \ע|שלכל ערך| בתחום, ממופה ערך בטווח.
לעומת זאת הפונקציות~$p₁^{-1}$ ו-$p₂^{-1}$ אשר התחום והטווח שלהן הוא~$𝓢$, הן
פונקציות חלקיות. שכן \ע|לא לכל ערך| של התחום מתאימות~$p₁^{-1}$ ו-$p₂^{-1}$ ערך
של הטווח. (בפרט,~$p₁^{-1}$ ו-$p₂^{-1}$ מוגדרות עבור ביטויי S מורכבים, ואינן
מוגדרות בעבור האטומים של~$𝓢$)

§§ הייצוג של $\mathbb Z$ בשפות תכנות 
ההחוג החיבורי~$ℤ$ מכיל אינסוף איברים, ולכן לא ניתן לייצג את כל המספרים הלקוחים
ממנו באף מחשב בגודל סופי. 

ישנן מספר שפות תכנות ובהן \E|Wofram Language| ו-\E|Newspeak| תומכות בייצוג של
מספרים מ-$ℤ$ שגדלם אינו חסום. המימוש אינו קשה: ניתן למשל ליצג כל מספר $n$ 
באמצעות רשימה (שאינה חסומה בגודלה) של הספרות בייצוג עשרוני של $n$. 
בשפות תכנות אלו, החישוב שבמספרים שלמים הוא "כמיטב המאמץ" (\E|best effort|).
חישובים מסויימים יביאו לכך שהחישוב יעצר בגלל מגבלות זמן או
זיכרון. אבל, אם החישוב יסתיים, הוא מובטח להיות נכון. 

שלמים במובן זה:  מתוך תשומת לב ליעילות התכניות הנכתבות בהן, שפות תכנות נוטות
לייצג מספרים שלמים באמצעות מילת מחשב \E|(word)| בת 32 או 64 ביטים, ולכן הן
תומכות רק בקבוצה סופית של מספרים שלמים הלקוחים מ-$ℤ$.
\def\kk#1{\texttt{#1}}

כך לדוגמה, הטיפוס \kk{long} בשפת \Java הוא קירוב של הקבוצה~$ℤ$: בטיפוס זה מוצגים
מספרים שלמים, שליליים וחיוביים \E|(unsigned int)| בשיטת "המשלים לשתיים" באמצעות מילה בת
64 ביטים.

הערכים האפשריים של הטיפוס \kk{long} הם מספרים מהתחום
בטיפוס הזה הוא \begin{equation}
-2^{63},…,2^{63}-1=-9,223,372,036,854,775,808,…,9,223,372,036,854,775,807
\end{equation}
על אף היות התחום גדול מאוד, הוא עדיין סופי, ולכן הוא כאיין לעומת
הקבוצה האינסופית~$ℤ$.

יש בטיפוס \kk{long} לא מעט זוגות של ערכים חיוביים, שהסכום שלהם הוא שלילי.
הסיבה לכך היא שהחישובים ב-\Java בטיפוס \kk{long} הם חישובים
בקבוצה~$ℤ_{2^{64}}$, הלא היא חוג השאריות מודולו~$2^{64}$. בחוג זה האבחנה בין
מספרים "חיוביים" ו"שליליים" אינה מוגדרת, ויחס ה"סדר" ב-$ℤ_{2^{64}}$ (ככל שיש
כזה) אינו מקיים תכונה חשובה של יחס הסדר של השלמים: שהעוקב של כל מספר גדול ממנו,
או בניסוח אחר, שאין מעגלים ביחס העוקב.

אנו מקבלים לכן שלא זו בלבד שהטיפוס \kk{long} הוא קירוב של~$ℤ$, גם "\cc+",
הסימן לציון החיבור, וגם "\cc*", הסימן לציון הכפל \Java (כאשר הם מופעלים על
ערכים מטיפוס \kk{long}), אינם מציינים את פעולות החיבור והכפל ב-$ℤ$, כי אם
קירוב סופי שלהן. בדומה לכך, סימן המינוס, "\cc-", מציין את פעולת ההופכי החיבורי
בקבוצה~$ℤ_{2^{64}}$, אך פעולה זו היא קירוב בלבד של פעולת ההופכי החיבורי שב-$ℤ$.
מספר הערכים השונים של הטיפוס \kk{long} הוא זוגי, וכיוון שהערך אפס נמנה עם ערכים
אלו, קיים ערך בטיפוס ששונה מאפס שהוא הההופכי החיבורי של עצמו, תכונה שאינה
מתקיימת ב-$ℤ$, בפרט מתקיים בטיפוס זה
\begin{equation*}
-❨-2^{63}❩=-2^{63}.
\end{equation*}

בניגוד למרבית שפות התכנות, ו-\E|Common Lisp| בתוכן, מיני-ליספ אינה תומכת
במספרים כלל. כיוון שכך, אין לה צורך להשתמש בטיפוסים כגון \kk{long}. מנגד,
כיוון שמיני-ליספ תומכת ב-$𝓢$ בלבד, יש לה צורך לתמוך בשלוש פעולות היסוד
על~$𝓢$, הלא הן~$p$,~$p₁^{-1}$, ו-$p₂^{-1}$.

האופרטורים של חיבור וכפל במרבית שפות תכנות מהווים קירוב בלבד של הפעולות על
השלמים. בניגוד לזאת, הפעולות בשפת ליספ הן מימוש מלא של הפונקציות
המתמטיות~$p$,~$p₁^{-1}$, ו-$p₂^{-1}$. כפי שנראה בתרגילים, ניתן להשתמש בשפת
ליספ כדי להגדיר יצוג מלא ולא מקורב של~$ℕ$ (המספרים הטבעיים),~$ℤ$ (השלמים),~$ℚ$
(הרציונליים),~$ℝ$ (הממשיים), ו-$ℂ$ (המרוכבים).

\פנה|טבלה:השוואה| משווה בין~$𝓢$ ובין החוג~$ℤ$, חוג המספרים השלמים,
מבחינת התמיכה בהם בשפות תכנות שונות.

§§ שלושת פעולות היסוד בשפת ליספ

הצגנו את שלוש פעולות היסוד על ביטויי~\E|S| כפונקציות מתמטיות מעל~$𝓢$, כשם
שהפעולות האריתמטיות הן פונקציות מתמטיות המוגדרות על החוג~$ℤ$. פעולות היסוד הם
גם פונציות של ליספ, והסימון שלהן נעשה על ידי אטומים, כשם שסימן הפלוס
(\T|"+"|) משמש לציון של פעולת החיבור בשפות תכנות אחרות.

שלושת האטומים המציינים את פעולות היסוד הם \T|cons|, \T|car|, ו-\T|cdr|:
\begin{enumerate}
  ✦ האטום \T|cons| מציין את הפונקציה~$p$, שהיא פונקציה אטומית המקבלת שני
  ביטויי~\E|S|, ומחזירה ביטוי~\E|S| שהוא זוג בו האיבר הראשון הוא הארגומנט
  הראשון לפונקציה, ואילו האיבר השני של הזוג הוא הארגומנט השני לפונקציה.

  ✦ האטום \T|car| מציין את הפונקציה~$p₁^{-1}$, שממומשת כפונקציה אטומית של
  ליספ. פונקציה זו מקבלת כארגומנט ביטוי~\E|S| אחד. אם ביטוי זה הוא ביטוי מורכב,
  כלומר ביטוי שהוא \E|dotted pair| הפונקציה מחזירה ביטוי~\E|S| שהוא האיבר
  הראשון בזוג ממנו הארגומנט בנוי.

  לעומת זאת, אם הארגומנט לפונקציה הוא אטום, הפונקציה נכשלת. כשלון זה דומה
  לכשלון של ניסיון לחלוקה באפס. כשם שלא כל הפעולות האריתמטיות מוגדרות על כל
  המספרים, לא כל הפונקציות המבניות מוגדרות על כל ביטויי~ה-\E|S|.

  ✦ באופן דומה, האטום \T|cdr| מציין את הפונקציה~$p₂^{-1}$ שממומשת גם היא
  כפונקציה אטומית. פונקציה זו המקבלת כארגומנט ביטוי~\E|S| אחד, ואם ביטוי זה
  הוא ביטוי מורכב, הפונקציה מחזירה ביטוי~\E|S| שהוא האיבר השני בזוג ממנו
  הארגומנט בנוי. כמו car הפונקציה cdr נכשלת אם היא מופעלת על אטום בודד
  או על הרשימה הריקה.
\end{enumerate}

נחדד את ההבדל בין שלושת האטומים ובין שלושת הפעולות אותן הם מציינים, ונזכיר
שהבדל זה אינו יחודי לשפת מיני-ליספ. בשפת~\CPL, יש הבדל בין הסימן \T|+| ובין
הקירוב לפעולת החיבור, אותו מציין סימן זה. בהמשך, נשתמש לא מעט באבחנה בין שם
הפונקציה, ובין גוף הפונקציה שאותו מציין השם.

§§ כתיב הרשימות
\תגית|פרק:רשימות|

לביטוי~\E|S| מורכב קוראים בשפת ליספ \E|dotted~pair|. מסיבות היסטוריות לאיבר
הראשון ב-\E|dotted pair| קוראים \E|car|, ולאיבר השני בו קוראים \E|cdr|.
(השמות car ו-\E|cdr| ציינו שמות של רגיסטרים במחשב \E|IBM~704| עליו מומשה ליספ
לראשונה.) לזוג כולו קוראים לעיתים \ע|רשומת cons|.

לביטוי~\E|S| אטומי בשפת ליספ קוראים אטום \E|(atom)|. דוגמאות לאטומים הן \E|A|,
\E|12B|, \E|ZZZ| ו-\E|+|. כפי שניתן להבחין ב\פנה|איור:מימוש| המחשבים העתיקים עליהם
הופעלה ליספ לראשונה, לא תמכו באותיות לועזיות קטנות. מסיבה זו האלפאבית של אטומים
בליספ אינו מכיל אותיות קטנות. כל הניבים של ליספ, ומיני-ליספ בתוכם, מתרגמת את
האותיות הקטנות לאותיות גדולות.

סדרת התווים המגדירה אטום יכולה להיות גם~$ε$, הסידרה הריקה. השם \E|nil| מציין את
האטום שסדרת התווים שלו היא~$ε$. כפי שנראה בהמשך, גם הכתיב \E|()| מציין את האטום
הזה. סדרת התווים המגדירה אטום היא חסרת משמעות בדרך כלל, אולם המתכנת בליספ יכול
להעניק לאטומים נבחרים משמעות. בנוסף, יש מספר אטומים שהמשמעות שלהם מוגדרת מראש
בשפה.

\ע|רשימה| \E|(list)| בליספ היא סדרה של פריטים העטופה בסוגריים. כל פריט ברשימה
יכול להיות אטום, \E|dotted pair|, או רשימה בעצמו. ניתן לכתוב רווחים לפני ואחרי
כל אחד מהפריטים, אולם שני אטומים רצופים ברשימה חייבים להיות מופרדים בסימן רווח
אחד לפחות.

כך, \E|(a b c d)| היא הרשימה המכילה ארבעה פריטים: האטומים \E|a|, \E|b|, \E|c|
ו-\E|d|. באופן דומה, \E|((a.c)c)| היא רשימה המכילה שני פריטים, שהראשון בהם הוא
ביטויי~\E|S| מורכב, \E|(a.c)|, והשני הוא האטום \E|c|. הרשימה הריקה, זו שאינה
מכילה אף פריט, נכתבת כ-\E|()|. כל הרשימות, למעט הרשימה הריקה הן ביטוי~\E|S|
מורכב. הרשימה הריקה היא גם אטום, בפרט, האטום \E|nil| הוא גם שמה של הרשימה
הריקה.

כל רשימה היא כתיב מקוצר לביטוי~\E|S|. הכתיב מוגדר באינדוקציה על אורך הרשימה:
הרשימה הריקה \E|()| שהיא גם כתיב אחר לאטום \E|nil|. רשימה שאינה ריקה, היא כתיב
מקוצר לביטוי~\E|S| מורכב, כלומר זוג של ביטויי~\E|S|. האיבר הראשון בזוג הוא
האיבר הראשון ברשימה. האיבר השני בזוג, הוא הייצוג של שארית הרשימה.

לפיכך, הרשימה \E|(a b c d)| היא כתיב אחר לביטוי~\E|S|
\begin{PASCAL}
a.b.c.d.nil
\end{PASCAL}

הפריטים ברשימה הם ביטויי~\E|S|, אבל כיוון שרשימה גם היא ביטוי~\E|S|, רשימה
יכולה להכיל בתוכה רשימות. למשל,
\begin{PASCAL}
  ((a b) c)
\end{PASCAL}
היא רשימה המכילה בתוכה שני פריטים, הראשון שבהם הוא רשימה בת שני אטומים, והשני
שבהם הוא אטום. רשימה זו ניתנת לתיאור באמצעות ביטוי~\E|S|,
\begin{PASCAL}
  ((a.(b.nil)).(c.nil))
\end{PASCAL}
\פנה|איור:רשימות| מציג רשימות אלו כעצים בינאריים מלאים.

\begin{figure}[H]
  \caption{יצוג רשימות כעצים בינאריים}
  \label{איור:רשימות}
  \centering
  \scriptsize
  \begin{LTR}
    \rowcolors{2}{orange!20}{white}
    \begin{tabular}{*5T}
      \mini{()}                     &
      \T|(A)|                       &
      \T|(A B)|                     &
      \T|(A B C D)|                 &
      \multicolumn1c{\T|((A B) C)|}
 ⏎
      \Forest{%
        s tree [$ε$,atom]
      }                             &
      \Forest{s tree [{},cons [A,atom] [$ε$,atom]]
      }                             &
      \Forest{s tree [{},cons [A,atom] [\relax,cons[B,atom][$ε$,atom]]]
      }                             &
      \Forest{%
      s tree [{},cons [A,atom]
      [{},cons [B,atom]
      [{},cons [C,atom]
      [{},cons [D,atom]
      [$ε$,atom]
      ]
      ]
      ]
      ]
      }                             &
      \Forest{%
      s tree [{},cons
      [{},cons
      [A,atom]
      [{},cons[B,atom] [$ε$,atom] ]
      ]
      [{},cons
      [C,atom]
      [$ε$,atom]
      ]
      ]
      }
    \end{tabular}
  \end{LTR}
\end{figure}

§§ פעולות היסוד על ביטויי~\E|S| כפעולות על רשימות
ניתן להסתכל על שלוש פעולות היסוד כפעולות על רשימות

\begin{enumerate}
  ✦ אם נעביר לפונקציה \T|cons| ערך כלשהו~$x$, כלומר ביטוי~\E|S| שיכול להיות
  אטומי או מורכב,~$x$ וביטוי~\E|S| אחר שהוא רשימה~$ℓ$, אזי הפונקציה תוסיף
  את~$x$ בתחילת הרשימה~$ℓ$: הפעלת cons על האטום a ועל הרשימה \E|((b~c)~d)|
  תחזיר את הרשימה \E|(a~(b~c)~d)|.

  ✦ אם הארגומנט לפונקציה \T|car| הוא רשימה~$ℓ$ שאיננה ריקה, אז הפונקציה מחזירה
  את הפריט הראשון ברשימה: הפעלת car על הרשימה בת שני איברים \E|((b~c)~d)| תחזיר
  את הפריט הראשון ברשימה זו, \E|(b c)|, שהוא בעצמו רשימה בת שני איברים.

  אם הארגומנט ל-\E|car| הוא אטום, ואפילו יהא זה האטום \mini{nil}, כלומר הרשימה
  הריקה, הפונקציה נכשלת.

  ✦ באופן דומה, אם הארגומנט לפונקציה \T|cdr| הוא רשימה~$ℓ$ שאיננה ריקה, אז
  הפונקציה מחזירה את הרשימה המתקבלת מ-$ℓ$ אחרי שהסרנו ממנה את הפריט הראשון שבה:
  הפעלת cdr על הרשימה \E|((b~c)~d)| תחזיר \E|(d)|, רשימה בת איבר אחד. הפונקציה
  \E|cdr| גם היא נכשלת אם היא מופעלת על רשימה ריקה, כלומר על האטום \E|nil|, או
  על כל אטום אחר.
\end{enumerate}

תכנות ברשימות מופיע ואף מאפיין שפות רבות אחרות מלבד ליספ. לפונקציה הדומה
ל-cons קוראים לעיתים \E|prepend|. כיוון ששלושת הפעולות הללו משתמשות ברשימה
כמחסנית, אנו מוצאים מקרים בהם קוראים ל-\E|cons| גם בשם \E|push|. דומה,
לפונקציה car קוראים בשפות תכנות אחרות בשמות כגון \E|first|, \E|top|, ו-\E|head|
(או אף בקיצור \E|hd|) ו-\E|top|, ולפונקציה cdr בשמות כמו \E|rest|, \E|body|,
\E|pop| ו-\E|tail| (או בקיצור \E|tl|).

§§ היגדים על ביטויי~\E|S|

הקבוצה~$ℤ$ היא קבוצה סדורה היטב. לגבי כל שני מספרים שלמים~$n₁,n₂∈ℤ$
מתקיים אחד, ורק אחד, מבין ההיגדים הבאים:~$n₁=n₂$,~$n₁<n₂$ או~$n₁>n₂$. היגד
היכול על איברי הקבוצה היכול להיות נכון או לא נכון, נקרא \ע|פרדיקט| על הקבוצה.

פרדיקט שיוויון דומה לז
אין יחס סדר דומה בקבוצת ביטויי ה-\E|S|, אבל ניתן לבדוק את תוכנם באמצעות
פונקציות מתאימות בליספ. פונקציות אלו הינן פרדיקטים על~$𝓢$.

שלוש פונקציות כאלו: \T|atom|, \T|null|, ו-\T|eq|, נמצאות בכל הניבים של ליספ,
ומיני-ליספ בתוכם.
\begin{enumerate}
  ✦ האטום \T|atom| מציין פונקציה אטומית של מיני-ליספ המקבלת ביטוי~\E|S| אחד
  ומחזירה את האטום \T|t| אם ארגומנט זה הוא אטום, ואחרת את האטום \T|nil|.
  בכתיב מתמטי,
  \begin{equation}
    \text{atom}:𝓢→\mathcal{B}
  \end{equation}
  כאשר~$𝓢$ מציינת את~$𝓢(Σ_{\text{Mini-Lisp}^*})$, קבוצת ביטויי ה-\E|S| של מיני-ליספ,
  וכאשר, \[
  \mathcal{B}=❴\text t, \text{nil}❵
\] מציינת את הקבוצה של שני הערכים ה"בוליאניים" ב-~$𝓢$, כלומר האטומים~t ו-\E|nil|.

  ✦ האטום \T|null| מציין פונקציה מוגדרת מראש במיני-ליספ, המקבלת ביטויי~\E|S|
  אחד ומחזירה את האטום \T|t|. אם ארגומנט זה הוא האטום \T|nil| ואחרת את האטום
  \T|t|. בניסוח אחר, אם הארגומנט לפונקציה הוא רשימה, אז הפונקציה מחזירה \T|t|
  אם ורק אם הרשימה ריקה, ו-\T|nil| בכל מקרה אחר. בכתיב מתימטי,
  \begin{equation}
    \text{null}:𝓢→\mathcal{B}
  \end{equation}

  ✦ האטום \T|eq| מציין את הפונקציה האטומית המקבלת שני ביטויי~\E|S| ומחזירה את
  האטום \T|t| אם שני הארגומנטים לפונקציה הם אטומים, ושני האטומים הללו שווים.
  בכל מקרה אחר, הפונקציה מחזירה את האטום \T|nil|.
  מתמטית ניתן לכתוב פונקציה זו כך
  \begin{equation}
    \text{eq}:𝓢⨉𝓢→\mathcal{B}
  \end{equation}
  כלומר, eq היא פונקציה מזוגות של ביטויי~\E|S| שבשפת מיני-ליספ
  לקבוצה~$\mathcal{B}$.
\end{enumerate}

במובן מסוים, הקבוצה~$\mathcal{B}$, היא קבוצת הערכים הבוליאניים של ליספ. ניתן
לחשוב על האטום \T|nil| כמסמן את הערך של שלילה לוגית, כלומר \E|false|, ועל האטום
\T|t| כמסמן את ערך האמת, \E|true|. אולם, בליספ כל ביטוי~\E|S| שאיננו האטום
\T|nil| נחשב כערך אמת כלומר כ-\E|true|. כלומר האטום \T|t| אינו הביטוי היחיד
המייצג את \E|true|. במקרה של הצלחה, כל שלושת פונקציות ההשוואה יכולות היו לכן
להחזיר כל ערך אחר שאיננו \T|nil|. בכל זאת, ובכדי לשמור על עיקביות, פונקציות אלו
\ע|מחזירות| את האטום \T|t| כל אימת שההשוואה מצליחה.

פונקציות אחרות של ליספ ה\ע|מקבלות| ביטויי~\E|S| כפרמטר, וצריכות להתייחס אליו
כערך בוליאני של אמת או שקר, יתייחסו לכל ערך שאינו \T|nil| כ-\E|true|. פונקציה
חשובה כזו, והנמצאת גם בניב המינימלי של מיני-ליספ היא הפונקציה cond המדמה את
פקודת התנאי (\E|if command|).

\begin{table}[!htbp]
  \caption[תמיכת שפות תכנות ב-$𝓢$ ובחוג~$ℤ$]{הפעולות הנדרשות בשפות תכנות לשם תמיכה בקבוצת ביטויי ה-S
  לעומת הפעולות הנדרשות לשם תמיכה בחוג~$ℤ$}
  \תגית|טבלה:השוואה|
\input lisp-compare-S-Z
\end{table}.
