\begin{enumerate}
  ✦ בדיקה מדוקדקת תגלה הבדל נוסף בין שני המימושים של הפונקציה \E|exists| חוץ
  מאשר ההבדל עליו מצביע הדיון. אתר הבדל זה, והסבר מדוע הוא אינו משנה את
  הסמנטיקה של המימוש.

  ✦ הפונקציה member היא פונקצית ספרייה סטנדרטית ברוב המימושים של ליספ. הפונקציה
  מקבלת אטום ורשימה, ומחזירה את זנב הרשימה הארוך ביותר שהאיבר הראשון שבו הוא
  האטום. אם האטום אינו מצוי ברשימה, הפונקציה מחזירה \E|nil|. ממש פונקציה זו
  במיני-ליספ, והסבר מדוע ניתן להחליף כל קריאה ל-exists בקריאה דומה
  ל-member עם אותם פרמטרים בדיוק.

  ✦ ממש במיני-ליספ את הפונקציה הרקורסיבית equal אשר משווה שני ביטויי~\E|S| אם
  הם זהים, כלומר אם הטופולוגיה שלהם כעצים בינאריים מלאים זהה, והאטומים המצוים
  בעלים זהים גם כן. הפונקציה מחזירה t במקרה של זהות, ו-nil אחרת.

  ✦ ב\פנה|איור:שיערוך| ישנה פונקציות אשר אינן יכולות לקרוא לעצמה רקורסיבית~(אם
  ישירות ואם בעקיפין). מיהן פונקציות אלו? מדוע אין צורך בהן ברקורסיה?

  ✦ חקור ביטויי~\E|S| שמקיימים את התכונה שהשיערוך שלהם מחזיר את הביטוי עצמו. האם
  יש ביטוים אטומיים כאלו? האם יש ביטוים מורכבים כאלו? (רמז: עיין בפונקציות
  המוגדרות מראש). כתוב פונקציה f המקיימת את התכונה הבאה: השיערוך של הביטוי
  \E|(f~$x$~$y$~$z$)| יחזיר את \E|(f~$x$~$y$~$z$)| עבור כל ערך של \E|$x$|,
  \E|$y$|, ו-\E|$z$|.

  ✦ היכן בודק המימוש של evaluate אם מספר הפרמטרים האקטואליים בהפעלה של
  ביטוי~$λ$ זהה למספר הפרמטרים הפורמליים שמוגדר בביטוי?

  ✦ המימוש של evaluate אינו בודק אם מספר הפרמטרים בפועל לפונקציות האטומיות
  הטריוויאליות תואם למספר הפרמטרים שהן אמורות לקבל. באילו מקרים העדר הבדיקה יביא
  לכך שמספר פרמטרים לא נכון לפונקציה טריביאלית לא ידווח כשגיאה? תקן את המימוש
  כך ששגיאה כזו תדווח.

  ✦ הסבר כיצד ניתן לתקן את evaluate כפי שתוארה כאן בכדי לתמוך בפונקציה אטומית
  \E|list| אשר מקבלת רשימה של ביטויי~\E|S|, ומחזירה את הרשימה של הביטוים לאחר
  שיערוכם.

  ✦ הסבר כיצד ניתן לתקן את evaluate כפי שתוארה כאן בכדי לתמוך בפונקציה אטומית
  \E|progn| אשר מקבלת רשימה של ביטויי~\E|S|, ומשערכת אותם לפי סדרם. תוצאת
  השיערוך היא תוצאת השיערוך של הפריט האחרון ברשימה, או nil במקרה שהרשימה ריקה.

  ✦ אילו שינוים יש לערוך במימוש של evaluate אם נשנה את מיני-ליספ כך שהפונקציות
  defun ו-quote תהיינה אטומיות, וכך שמיני-ליספ לא תתמוך בפונקציות המוגדרות
  מראש \E|lambda|, \E|nlambda| ו-\E|ndefun|.

  ✦ נגדיר \ע|יצוג אונארי| של המספרים הטבעיים באמצעות ביטוי-\E|S| באופן הבא:
  \begin{itemize}
    ✦ המספר~0 מיוצג על ידי \E|nil|,
    ✦ המספר~1 מיוצג על ידי הרשימה המכילה את \E|nil|, כלומר הרשימה \E|(nil)|,
    ✦ המספר~2 מיוצג על ידי הרשימה המכילה את המספר~1, כלומר \E|((nil))|,
    ✦ המספר~3 על ידי הרשימה המכילה את המספר~2, כלומר, \E|(((nil)))|,
    וכן הלאה.
  \end{itemize}
  הגדר פונקציה uadd המקבלת שתי רשימות המהוות יצוג אונארי של מספרים,
  ומחזירה רשימה שהיא יצוג אונארי של סכום המספרים. החיבור~1+2 יוצג על ידי
  הקריאה
  \begin{LISP}
> (uadd (nil) ((nil)))
(((NIL)))
\end{LISP}
  אשר, כפי שאנו רואים, מחזירה את הייצוג של המספר~3.
  כדאי להשתמש בהגדרות העזר הבאות:
  \begin{LISP}
(defun s(x) (cons x ())) ; the successor function
(defun p(x) (car x)) ; the predecessor function
; symbolic names for the first few numbers
(setq zero nil)
(setq one (s zero))
(setq two (s one))
(setq three (s two))
(setq four (s three))
(setq five ‘((((())))))
\end{LISP}
  בהגדרות אלו נקבל שהקריאה
  \lisp{(uadd three two)}
  תחזיר \lisp{((((()))))}.

  ✦ כתוב פונקציה בשם umult אשר מכפילה שני מספרים טבעיים בייצוג אונארי.

  ✦ \ע|בייצוג בינארי| על ידי רשימות, כל מספר מייוצג על ידי רשימת אטומים, כאשר
  כל אטום מייצג ספרה בינארית: את הספרה~$0$ מייצג האטום Z, ואת הספרה~$1$ מייצג
  את האטום O. המספר~$5$ מיוצג על ידי הרשימה \begin{LISP}
(O Z O)
\end{LISP} שכן הייצוג הבינארי של~$5$ הוא~$101$. הרשימות נכתבות ב-little-endian,
  כלומר, הביט המשמעותי פחות, מופיע ראשון. לדוגמה, המספר~$6$ מיוצג על ידי הרשימה
  \begin{LISP}
 (Z O O)
 \end{LISP}
  שכן הייצוג הבינארי של~$6$ הוא~$110$. אורך הרשימה תלוי בגודל המספר.
  לדוגמה, המספר~$3$ בכתיב בינארי מיוצג על ידי הרשימה
  \begin{LISP}
 (O O)
 \end{LISP} הייצוג הבינארי של~$3$ הוא~$11$. ניתן להוסיף אטומים של Z בסוף
  הרשימה. כל הרשימות הבאות הן יצוג של המספר~$3$.
  \begin{LISP}
(O O)
(O O Z)
(O O Z Z)
(O O Z Z Z)
\end{LISP}
  ובאופן דומה, כל הרשימות הבאות הן יצוג של המספר~$0$,
  \begin{LISP}
()
(Z)
(Z Z)
(Z Z Z)
\end{LISP}
  בתרגיל זה הנך נדרש לכתוב שתי פונקציות:
  \begin{itemize}
    ✦ כתוב פונקציה במיני-ליספ בשם bnormalize המקבלת מספר בייצוג בינארי כרשימה,
    ומחזירה את הייצוג הקצר ביותר שלו באותה דרך.
    ✦ כתוב פונקציה במיני-ליספ בשם badd המקבלת שתי רשימות המהוות יצוג בינארי
    של מספר טבעי לא שלילי, ומחזירות רשימה שהיא היצוג הבינארי של סכומם.
    הפונקציה צריכה להחזיר הרשימה הקצרה ביותר מבין הרשימות שמייצגות את הסכום,
    אבל היא אינה יכולה להניח שהמספרים אותם עליה לחבר מיוצגים כרשימה קצרה
    ביותר.
  \end{itemize}

  ✦ כתוב פונקציה בשם bmult אשר מכפילה שני מספרים טבעיים בייצוג בינארי.

  ✦ השתמש ב-ndefun, ב-eval, וב-set כדי לממש במיני-ליספ את הפונקציה \E|setq| של
  \E|Common Lisp| אשר דומה לפונקציה set:
  \ספרר
  ✦ הפונקציה setq מקבלת שני פרמטרים, a ו-\E|e| והיא קושרת את e לאטום \E|a|
  ב-\E|a-list|.
  ✦ בניגוד ל-\E|set|, setq \ע|אינה משערכת| את הפרמטר~a טרם ביצוע הקישור.
  ✦ בדומה לפונקציות set ו-setq הפונקציה nsetq \ע|משערכת| את הפרמטר~e טרם ביצוע
  הקישור. שיערוך הביטוי \T|(nsetq a (car '((1 (2))~3))| יקשור את האטום a
  לרשימה-\T|(1 (2))|.
  ✦ הערך אותה מחזירה setq הוא אותו הערך אותו מחזירה \E|set|.
===
  \begin{LISP}
> (setq a (car '((1 (2))~3))
(1 (2))
> a
(1 (2))
\end{LISP}

  ✦ השתמש ב-setq וב-cond כדי לכתוב פונקציה בשם \E|nsetq| אשר דומה לפונקציה
  \E|setq|, ומשתמשת בה כדי לקיים את התכונות הבאות:
  \ספרר
  ✦ הפונקציה nsetq מקבלת שני פרמטרים, a ו-\E|e| של והיא קושרת את e לאטום \E|a|
  ב-\E|a-list|.
  ✦ בדומה ל-\E|setq|, הפונקציה nsetq \ע|אינה משערכת| את הפרמטר a טרם ביצוע
  הקישור.
  ✦ בדומה הן ל-set של מיני-ליספ והן ל-setq הפונקציה nsetq \ע|משערכת| את
  הפרמטר~e טרם ביצוע הקישור. שיערוך הביטוי \T|(nsetq a (car '((1 (2))~3))|
  יקשור את האטום a לרשימה-\T|(1 (2))|.
  ✦ בניגוד לפונקציות set ו-setq, הפונקציה nsetq מחזירה את האטום nil ללא תלות
  בערכם של~a ושל \E|e|.
===
  \begin{LISP}
> (nsetq a (car '((1 (2))~3))
NIL
> a
(1 (2))
> (nsetq b NIL)
NIL
> b
NIL
\end{LISP}
\end{enumerate}

