§§ ליספ מיניאטורית
שפת ליספ היא שפת תכנות פעילה, המעשירה את התכנות הפונקציונלי במבנים חדשים
ומתקדמים כגון תכנות מונחה עצמים. אבל, הענין שלנו אינו בליספ כשפת תכנות, אלא
ברעיונות היסודיים שמאחורי שפת התכנות ליספ: תכנות פונקציונלי, ביטויי-S, חישוב
סימבולי, חישוב על רשימות, שיערוך, שמות ומשמעותם, סביבה וטווח.

\ע|מיני-ליפס| ובאנגלית, \E|Miniature~Lisp| או בקיצור \E|Mini-Lisp| היא שפת
תיכנות מיניאטורית המלקטת מליספ, שפת התכנות ה"אמיתית", את קוויה העיקריים. למעט
הבדלים פעוטים, תכנית מיני-ליספ היא, בדרך כלל, תכנית חוקית של \E|Common Lisp|.
אבל, בדרך כלל, תכנית של \E|Common Lisp| אינה תכנית חוקית של מיני-ליספ.

 הניב של ליספ הבנוי על גלעין זה קרוי הניבים השונים של ליספ משתמשים גם הם
 \פנה|הגדרה:S| ביטויי-\E|S|, אלא שהם מוסיפים עליה קיצורים שונים. במיני-ליספ
נשתמש בשני קיצורים:
\אבגד
✦ כתיב הרשימות, שיוצג כאן
✦ סימן ה-\E|quote| \E|(')|, שיוצג בהמשך ב\פנה|פרק:quote|
===

בניגוד לניבים האחרים של ליספ, שפת מיני-ליספ אינה תומכת במספרים ובפעולות
אריתמטיות, והיא מזניחה את ענין היעילות. על אף המינימליות של שפת מיני-ליספ,
השפה היא מה שקרוי שפה "אוניברסלית". כלומר, ניתן לכתוב במיני-ליספ כל תכנית שאפשר
לכתוב בשפות תכנות סגפניות פחות ממנה, כמו פסקל ו-\E|C| למשל. כך ניתן להוסיף
למיני-ליספ תמיכה במספרים טבעיים. באופן דומה ניתן להרחיבה כך שתתמוך במספרים
שליליים, רציונליים, ממשיים, מרוכבים, וגם מחרוזות, מבני נתונים, מערכים, כמו גם
בתכונות של ניבים אחרים של ליספ, או אף שפות אחרות. \פנה|פרק:אוניברסליות| שבהמשך
ירחיב את הדיון באוניבסליות של שפות תכנות.

לא זו בלבד שהביצוע של תכניות בשפת מיני-ליספ אינו יעיל, גם תכנות בשפה רחוק
מלהיות נוח, בהעדר, למשל, תמיכה מובנית בפעולת החיבור או בפעולות קלט/פלט. אכן,
שפת מיני-ליספ אינה משמשת לתכנות של ממש. היא פותחה לצרכים לימודיים בלבד, ואין
כוונה להשתמש בה לצרכים אחרים .

מיני-ליספ תוכננה להיות מהירה ללימוד. וניתן להכיר אותה על בוריה בתוך שעות ספורות
לכל היותר: לבד מאלגוריתם השיערוך והכתיב הפשוט של ביטויי~\E|S|, יש להכיר
גם פונקציות בסיסיות ספורות מהן נבנות תכניות במיני-ליספ.

§§ המרכיבים של מיני-ליספ
ישנם שלושה מרכיבים עיקריים למיני-ליספ:
\begin{description}
  ✦ [פונקציות אטומיות.] אילו הן פונקציות פשוטות אשר הן "אקסיומטיות", כלומר,
  הגלעין מניח שהן קיימות וכי הן מצייתות למפרט מוגדר היטב. אולם, האופן שבו
  ממומשות הפונקציות האטומיות אינו חלק ממיני-ליספ.

  לעיתים קוראים לפונקציות האטומיות גם \ע|פונקציות פרימיטיביות|, במובן זה שהן
  הבסיסיות ביותר. אנחנו נעדיף את המינוח "האטומי", המדגיש את העובדה שהן בלתי
  ניתנות ל-"חלוקה", ואם נעיין בקרבי המימוש שלהן, לא נמצא שם פונקציות אחרות של
  מיני-ליספ, אלא מבנים אחרים.

  ✦ [פונקציות מוגדרות מראש.] בנוסף לפונקציות האטומיות, מציעה שפת מיני-ליספ
  לנוחות המשתמש בה מספר פונקציות נוספות, אשר אותן מממש הגלעין באמצעות קריאה
  לאחת או יותר מהפונקציות האטומיות.

  נבחין בין פונקציות מוגדרות מראש ובין \ע|פונקציות ספרייה|. ספרייה של פונקציות
  היא אוסף של פונקציות המאורגנות יחד והממוממשות באמצעות האטומים של השפה.
  המשמשות למטרה קרובה או דומה. המשתמש בשפה רשאי, אך אינו חייב להשתמש בספרייה,
  ולכן פונקציות הספרייה הן אופציונליות בעבורו. לעומתן, קבוצת הפונקציות המוגדרות
  מראש בשפה היא חלק מהגדרת שפת התכנות, והמשתמש אינו יכול לבחור אם להשתמש בה אם
  לאו.

  בשפת התכנות~\CPL אין פונקציות מוגדרות מראש. גם פונקציה בסיסית כגון printf
  המשמשת להוצאת פלט ממוממשת כחלק מספרייה. ישנן סיפריות רבות לשפת~\CPL, אך
  הספרייה אשר מכילה את הפונקציה printf היא יחודית בכך שהיא קרויה \ע|הספרייה
  הסטנדרטית| (בה' הידיעה), או \E|libc|. מקובל לכלול את \E|libc| כחלק
  מתכניות~\CPL. אולם, ניתן לכתוב תכניות~\CPL גם מבלי להשתמש בספרייה זו, וישנן
  תכניות שימושיות שאינן משתמשות כלל בסיפריות של השפה.

  המקבילה בפסקל לפונקציה printf בשפת~\CPL, היא הפרוצדורה הידועה בשם
  \E|WriteLn|. פרוצדורה זו מוגדרת מראש בשפה. לא ניתן לכתוב תכנית פסקל אשר אינה
  כוללת את \E|WriteLn|, אם כי המתכנת אינו חייב להשתמש בפרוצדורה זו, והוא אף
  יכול להשתמש בשם \E|WriteLn| לצרכיו, ובכך להסתיר את הפרוצדורה המקורית.

  ✦[אלגוריתם השיערוך] שפת מיני-ליספ, כמו ניבים אחרים של ליספ, מכילה פונקציה
  מיוחדת, \E|eval| שמה, אשר מקבלת ביטוי~\E|S| ומשערכת אותו. מסיבות טכניות
  הפונקציה eval נחשבת אף היא פונקציה אטומית, אולם, את רובה ככולה ניתן לממש
  כפונקצית ספרייה.
\end{description}

§§ הפונקציות האטומיות

במיני-ליספ יש שש פונקציות אטומיות \ע|טהורות|.
\ציינן
✦ \ע|שלוש פונקציות מבניות|: \E|car|, \E|cdr| ו-\E|cons|, אשר מאפשרות ליצור
ביטוי \E|S| משני ביטויים אחרים ולפרק אותו לשני לחלקיו.

✦ \ע|שתי פונקציות לוגיות|: \E|atom| ו-\E|eq| המאפשרות לבדוק את תוכנו של
ביטוי~\E|S|.

✦ הפונקציה \E|cond| המשמשת לצורך חישוב מותנה, בדוגמה לפקודות התנאי בשפות
  תכנות אחרות.
===
פונקציות \ע|טהורות| הן פונקציות של שפת תכנות המתנהגות כמו פונקציות מתימטיות.
פונקציה בשפת~\CPL(לדוגמה) היא אינה טהורה, אם היא בעלת תופעות לוואי, או אם יתכן
ששתי קריאות שונות אליה עם אותם ארגומנטים בדיוק, תחזרנה ערכים שונים.

פונקציה שקוראת קלט, כמו למשל הפונקציה \E|read| בשפת~\CPL, לא יכולה להיות
פונקציה טהורה. גם פונקציה שמייצרת פלט, כמו הפונקציה \E|printf| בשפת~\CPL,
לא יכולה להיות פונקציה טהורה. הפונקציה \E|sin| המוגדרת מראש בשפת פסקל היא
פונקציה טהורה.

הפונקציה set במיני-ליספ היא פונקציה אטומית שאינה טהורה. החישוב של \E|set| מביא
לקישור בין שם (אטום) ובין ערך (ביטוי-\E|S|). אכן, השם "פונקציה" אינו יאה
לפונקציה \E|"set"|. בשפות כמו פסקל, נעשה מאמץ להשתמש בשם "פרוצדורה" עבור
פונקציות אשר אינן טהורות.

פונקציה טהורה אינה חייבת להיות פונקציה מלאה. הפונקציה \E|succ| בשפת פסקל,
המקבלת ערך הנלקח מטיפוס מנוי \E|(enumerated type)| ומחזירה את הערך
העוקב לו היא פונקציה חלקית.
\begin{Pascal}
PROGRAM
TYPE Day=(Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday);
VAR today: Day;
BEGIN day=Saturday; day=succ(day) END.
\end{Pascal}

פונקציה חלקית היא פונקציה שערכה אינו מוגדר עבור ערכים מסויימים של הפרמטרים.
הפונקציות car ו-\E|cdr|. לעומתן, הפונקציה \E|cons| היא פונקציה מלאה.

הפונקציה error במיני-ליספ היא פונקציה אטומית חלקית. אולם בניגוד לפונקציות car
ו-\E|cdr| אשר מוגדרות עבור פרמטרים מסויימים, הפונקציה error אינה מוגדרת עבור
אף ערך של הפרמטרים שלה. קריאה ל-\E|error| לא תחזיר לעולם ערך תקין.
הפונקציה אינה טהורה, במובן זה שיש לה תופעות לוואי \E|(side effects)|: קריאה
לפונקציה זו תביא לעצירת החישוב, וחזרה לזרז של ה-\E|REPL|.

ראינו אם כן שתי פונקציות פרימיטיביות נוספות:
\begin{itemize}
  ✦ הפונקציה \E|set| המאפשרת לתת שמות לביטויי~\E|S|, ולאפשר למתכנת להגדיר
  פונקציות נוספות משלו.
  ✦ הפונקציה \E|error| המסייעת בטיפול במקרים שבהם החישוב נתקל בשגיאה.
\end{itemize}
כל הפונקציות האטומיות של מיני-ליספ הן גם פונקציות אטומיות של מרבית הניבים
החשובים של ליספ, ובפרט של \E|Common Lisp|. אולם, בניבים אחרים של ליספ, יש בדרך
כלל מספר רב של פונקציות אטומיות נוספות.

הערכים בהם מטפלת שפת ליספ הם ביטויי~\E|S|, ונדרשות במיני-ליספ שמונה פונקציות
אטומיות כדי לבצע את כל המניפולציות הנחוצות של ערכים אלו, וביניהן פעולה המקבילה
להצבה ופעולה המקבילה להדפסת שגיאה. בהשוואה לאלו, התמיכה של שפת פסקל בטיפוס של
מספרים שלמים משתמשת ב-14 פריטים שונים:~5 אופרטורים אריתמטיים בינאריים,~2
אופרטורים אריתמטיים אונאריים,~6 אופרטורים של השוואה, וכן סימן מיוחד, \E|:=|,
אשר אינו נחשב לאופרטור בשפת פסקל, לציון פעולת ההצבה. (שפת פסקל אינה מציעה תמיכה
יחודית לתמיכה בשגיאות).

\פנה|טבלה:אטומיות| שבהמשך מתארת את הפונקציות האטומיות במדויק. מיני-ליספ מעלה
על נס את המינימליות, ואכן למרות שהטבלה מביאה מפרט מלא של הפונקציות הללו ואת כל
מה שנדרש כדי להשתמש בהן, היא אינה משתרעת על פני יותר ממחצית העמוד. (יש עדיין
צורך בכמה הגדרות וסימונים כדי לקרוא את הטבלה ולהבין את משמעות~8 הפונקציות בה,
אולם ניכר כי תיאורן קצר.)

אנו נתאר ראשית את הפונקציות המבניות, ואחר כך את הפונקציות הלוגיות \E|atom|,
ו-\E|eq| יחד עם הפונקציה המוגדרת מראש \E|null|. המשך הדיון יוביל לתיאורה של
הפונקציה \E|set|, ואחריה \E|cond|. תורה של \E|error| יגיע כאשר נממש את
אלגוריתם השיערוך במיני-ליספ.

§§ פונקציות מוגדרות מראש

מיני-ליספ מכילה שמונה פונקציות מוגדרות מראש, כלומר פונקציות הכתובות בשפת
מיני-ליספ תוך שימוש בפונקציות האטומיות, ואשר נטענות תמיד יחד עם מיני-ליספ.

\ציינן
✦ \ע|קבועים| (פונקציות ללא פרמטרים):
\begin{itemize}
  ✦ \E|t| (המציין את הערך הבוליאני של אמת).
  ✦ \E|nil| (המציין את הערך הבוליאני של שקר).
\end{itemize}
✦ \ע|פונקציה לוגית|: \E|null| (פונקציה חד-מקומיות הבודקת אם ביטוי הוא \E|nil|).
✦ \ע| פונקציות המסייעות בהגדרת פונקציות|:
\E|quote|, \E|defun|, \E|ndefun|, \E|lambda| ו-\E|nlambda|.
\begin{itemize}
  ✦ הפונקציה defun משמשת להגדרת פונקציות חדשות.
  ✦ הפונקציה quote משמשת למניעת השיערוך של ביטויי~\E|S|.
  ✦ בפונקציות \E|ndefun|, \E|lambda| ו-\E|nlambda|, נדון בהמשך.
\end{itemize}
===

מלבד ndefun ו-nlambda ניתן למצוא, לעיתים בשינוים קלים, את הפונקציות המוגדרות
מראש של מיני-ליספ גם ב-\E|Common lisp| ובניבים אחרים של השפה.
\פנה|טבלה:מראש| שבהמשך מתארת את הפונקציות המוגדרות מראש, והיא כוללת, בנוסף
לתיאור הפונקציות הללו, גם את המימוש המלא שלהן במיני-ליספ, ובכל זאת, טבלה זו
קצרה אף יותר מ\פנה|טבלה:אטומיות| המתארת את הפונקציות האטומיות.

בהמשך נראה כי מימושן של הפונקציות המוגדרות מראש נעשה באמצעות קשירה
(\E|binding|) של שמן למה שקרוי "ביטוי \E|lambda|" או "ביטוי \E|nlambda|",
באמצעות הפונקציה \E|set| (ישירות או בעקיפין). במונח binding אנו מתכוונים לקישור
בין שם לבין המשוים אותו מציין השם. נניח ש-$f$ היא פונקציה מוגדרת מראש. אזי~$f$
היא ביטוי~\E|S| שהוא מהצורה המיוחדת של ביטוי \E|lambda| או מהצורה המיוחדת של
ביטוי \E|nlambda|. מתן שם למשוים~$f$ הוא הקישור בין אטום של מיני-ליספ (שהוא
השם) למשוים~$f$.

קישור של שם למשוים קיים בכל שפות התכנות: כאשר אנו מגדירים בשפת תכנות כמו פסקל
משתנה אשר שמו הוא \T|i|, אנו נותנים שם לתא בזכרון שמכיל את ערכו של המשתנה.
המשוים הוא תא בזיכרון שמכיל את ערכו של המשתנה, ו-\T|i| הוא השם שאנו קושרים לתא
זה. המונחים קישור והגדרה הם זהים: פונקציות מוגדרות מראש בשפת מיני-ליספ הן
פונקציות אשר הקישור בין שמן ובין הגוף שלהן נעשה עוד טרם ריצת התכנית. כאשר אנו
אומרים שהסימן \T|+| מציין את פעולת החיבור בשפת פסקל, אנו בעצם אומרים שיש קישור
בין הסימן ובין הפעולה. גם הסימן \T|+| וגם \T|i| הם שמות של משוימים. הסימן~\T|+|
מציין משוים שהוא פעולה, ואילו \T|i| מציין משוים שהוא משתנה. הבדל אחד, אך לא
הבדל מהותי, בין~\T|+| ובין~\T|i| הוא שלמתכנת (בשפת פסקל לפחות) אין אפשרות
להשתמש בסימן~\T|+| כדי לציין משוימים שהוא יצר.

הדיון כאן יתאר תחילה את הקבועים, כלומר הפונקציות האפס-מקומיות, \E|t| ו-\E|nil|,
ולאחר את הפונקציה החד-מקומית \E|null|. אחר כך נעבור לתאר את \E|quote|, את
\E|defun| ואת \E|lambda|. הפונקציות \E|ndefun| ושל \E|nlambda| דורשות מעט יותר
תשומת לב, והן תוצגנה אחרונות.

§§ האינטרפרטר של ליספ
אנו רואים כי המונח שיערוך כולל בתוכו שני מרכיבים עיקריים: ראשית, איתור המשמעות
של הסמלים המופיעים בביטוי, ושנית, חישוב הביטוי בהתאם למשמעות זו.

בדרך כלל מרכיב החישוב של השיערוך מחשב ביטוי חדש, אך לעיתים השיערוך מייצר משמעות
בעבור סמלים שלא הייתה להם משמעות טרם השיערוך: השיערוך אינו לקוח בלבד
בלבד של הגדרות הסמלים, הוא גם עשוי לייצר הגדרות חדשות כאלו.

בשפות תכנות כדוגמת~\CPL ופסקל, העוברות \ע|הידור| \E|(compilation)| שני מרכיבי
השיערוך נפרדים. מתן המשמעות לסמלים ואיתור המשמעות של סמלים נעשה על ידי
ה\ע|מהדר| \E|(compiler)|. החישוב עצמו נעשה בזמן ריצת התכנית. בליספ, כמו בשפות
אחרות שבהן עיבוד התכנית בשפה נעשה באמצעות אינטרפרטציה \E|(interpretation)| של
תכניות, שני השלבים של השיערוך נעשים על ידי האינטרפרטר \E|(interpreter)| אשר
קורא תכניות ומשערך אותן בזו אחר זו. האינטרפרטציה כוללת לכן לא רק את תהליך
החישוב, אלא גם את התהליכים הנלווים של מתן משמעות לסמלים, ואיתור משמעות זו.

\begin{minipage}{0.9\linewidth}
  \centering
  \footnotesize
\begin{mdframed}[backgroundcolor=Lavender!20]
    האינטרפרטר של ליספ, כמו תכנת מאקסימה (\פנה|איור:מאקסימה|), האינטרפרטר של
    פרולוג, \E|bash| ושפות תכנות אחרות העוברות אינטרפרטציה, עובד במחזורים,
    בשיטה הידועה בשם
    \LR{\textbf Read \textbf Evaluate \textbf Print \textbf Loop}
    או בראשי תיבות \E|REPL|:
    \ספרר
    ✦ \E|READ|: האינטרפרטר קורא סידרת תווים מהקלט, ומנסה להציג סידרה זו כמבנה
    בשפת התכנות. במקרה של ליספ, האינטרפרטר קורא סדרת תווים, ומנסה להציג
    אות כביטוי~\E|S|. אם לא ניתן לעשות כן, האינטרפרטר מדפיס הודעת שגיאה וחוזר
    לתחילת הלולאה של \E|REPL|, כלומר חוזר לקרוא קלט חדש.
    ✦ \E|EVALUATE|: האינטרפרטר משערך את ערכו של הביטוי שקרא.
    ✦ \E|PRINT|: אם השיערוך של הקלט מצליח, אז האינטרפרטר ידפיס את תוצאת
    השיערוך. אחרת, האינטרפרטר ידפיס הודעת שגיאה מתאימה.
    ✦\E|LOOP|: האינטרפרטר חוזר לצעד הראשון, לקריאת הקלט הבא.
===
  \end{mdframed}
\end{minipage}

\פנה|איור:REPL| מביא את הקוד שמממש את ה-\E|REPL| באינטרפרטר של מיני-ליספ.
\begin{figure}[H]
\כיתוב|מימוש REPL בתוך האינטרפרטר של מיני-ליספ|
\תגית|איור:REPL|
\input{mini-lisp-REPL.tex}
\end{figure}

כפי שאפשר לראות באיור, האינטרפרטר של ליספ מכיל שלושה מרכיבים עיקריים:
\begin{enumerate}

  ✦ ה-Reader אשר קורא קלט מתוך זרם של תווים, מנתח אותו כתיאור טסקטואלי של
  ביטוי~S, ומחזיר מבנה נתונים המקודד את ביטוי ה-S. לביטוי ה-\E|S|
  המתאים
  לתווים אלו. באיור, מרכיב זה הוא הפונקציה \mini{read()},
  אשר מזרזת את המשתמש באינטרפרטר להזין קלט תקין, מעירה לו אם הקלט אינו תקין
  ומזרזת אותו שוב, עד אשר מתקבל קלט שהוא ביטוי כזה.

  אם לא ניתן לקבל יותר קלט, פונקציה זו אינה מחזירה תוצאה, כלל. במקום זאת היא
  "זורקת" \ע|חריגה| (\E|exception|). במקרה זה, אין אפשרות להמשיך בלולאת
  ה-\E|REPL|, והחישוב מסתיים.

  ✦ המשערך \E|(Evaluator)| אשר משערך ביטויי~\E|S| אלו. באיור, מרכיב זה הוא
  הפונקציה \mini{eval()}, אשר מקבלת ביטוי לשיערוך, ומחזירה את תוצאת השיערוך.

  אם השיערוך נכשל, פונקציה זו אינה מחזירה ערך, אלא זורקת חריגה, שגם היא במבנה
  של ביטוי~\E|S|. כשלון בשיערוך של ביטוי מסויים אינו מפסיק את מחזורי
  ה-\E|REPL|.

  השיערוך יכול להיכשל גם מסיבות של כשל "תשתיתי", בעיקר כאשר כאשר משאבי הזיכרון
  הנדרשים לו גדולים מאלו העומדים לרשות האינטרפרטר. כישלון מסוג זה יביא לסיום עבודתו
  של האינטרפרטר.

  ✦ ה-Printer אשר מקבל ביטוי~\E|S| כמבנה נתונים ומתרגם אותו לסדרת תווים אשר
  מייצגת מבנה נתונים זה. בפנה|איור:REPL| מרכיב זה הוא הפונקציה \mini{println()}.
\end{enumerate}

כאן נניח שה-Reader וה-Printer נתונים והם דומים לאלו שבכל ניב של ליספ, ונעסוק
בעיקר במשערך של מיני-ליספ.

המשמעות של המונח \ע|כתיב| היא שמרכיב ה-Reader של האינטרפרטר של ליספ יכול לקרוא
ביטויי~\E|S| הנתונים בכתיב הרשימות ושמרכיב ה-Printer של האינטרפרטר יתרגם
ביטוי~\E|S| לכתיב הרשימות כשהדבר אפשרי (לא כל ביטוי~\E|S| ניתן להיכתב בכתיב
הרשימות; למשל הביטוי \E|(a.b)| אינו ניתן להכתב כרשימה, אבל כל רשימה ניתנת
להיכתב כביטוי~\E|S|). בהעדר סיבה מיוחדת, מתכנתי ליספ נוהגים לכתוב ביטויי~\E|S|
בכתיב הרשימות בכל אימת שניתן לעשות זאת.

ראינו שביטויי~\E|S| ניתנים להצגה כעץ בינארי שבו העלים, והעלים בלבד, מכילים
סמלים. אם ביטוי~\E|S| ניתן להכתב כרשימה של רשימות, אז ניתן להציג את הביטוי
הזה כ\ע|עץ| שבו קיים סמל בכל צומת פנימי ובכל עלה, ומספר הבנים של כל צומת פנימי
יכול להיות כלשהו.
