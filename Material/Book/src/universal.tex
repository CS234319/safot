\def\Title{מאוניברסליות לאלגנטיות}
\input{wrap}

§ שפות תכנות אוניברסליות
\תגית|פרק:אוניברסליות|

אנו אומרים ששפת תכנות היא \ע|אוניברסלית| (\E|universal|) או \ע|טיורינג-שלמה| אם
(\E|Turing-complete|)אם ניתן לממש בתוך שפה זו \ע|כל| שפה אחרת. בניסוח מדויק
 יותר, שפה~$𝓛$ היא אוניברסלית, אם עבור כל שפה תכנות אחרת~$𝓠$ ניתן לכתוב
בשפה~$𝓛$ תכנית, תכנית הקרויה \ע|תכנית אוניברסלית עבור~$𝓠$|, המממשת את~$𝓠$
בתוך~$𝓛$. במילים אחרות ישנה בשפה~$𝓛$ לפחות תכנית אחת~$ℓ_𝓠$,~$ℓ_𝓠∈𝓛$, המסוגלת
להדר, לבצע, או לממש בכל דרך אחרת \ע|כל| תכנית~$q$ בשפת~$𝓠$: במקום \ע|להריץ|
(\E|\emph{run},~or \emph{execute}|) את~$q$ בשפת התכנות~$𝓠$, ניתן להריץ בשפה~$𝓛$
את התכנית~$ℓ_𝓠$ על הקלט~$q$, ושתי ההרצות תהיינה \ע|שקולות|.

המימוש של מיני-ליספ נעשה באמצעות תכניות אוניברסליות כאלו. המימוש הראשון של
מיני-ליספ נעשה בשפה דמוית \E|C| אשר בה נכתבה תכנית אוניברסלית בעבור למיני-ליספ.
ברוח המינימליות של מיני-ליספ, תכנית אוניברסלית זו את נושאת השם הקצר
במיוחד~\cd{m} והיא מופעלת באמצעות הוא באמצעות המעטפת של מערכת ההפעלה (e.g., the
shell named bash as found on Linux system|).

מיני-ליספ זכתה גם למימוש בתכנית אוניברסלית בשפת \E|JavaScipt|. כדי להשתמש
בתכנית אוניברסלית יש לגלוש באמצעות הדפדפן לדף HTML המכיל בתוכו את התכנית
האוניברסלית הזו. מתברר כי המימוש של כל שפת תכנות נעשה באמצעות תכניות
אוניברסליות כאלו: מהדר לשפת Java הכתוב בשפת~\E|C|, מהדר של שפת פסקל הכתוב בשפת
מכונה, אינטרפרטר של שפת פרולוג הכתוב בשפת \E|Java|, וכו'.

נציין כי כמעט כל שפות התכנות, ובכללן פסקל, \E|C|, וגם מיני-ליספ, הינן
אוניברסליות. השפות שאינן אוניברסליות הינן מעטות מאוד, וכוללות בתוכן מספר שפות
לעיבוד נתונים ובכללן \E|Datalog| ו-\E|SQL|, וכן שפות מועטות כגון
\E|LOOP| אשר תוכננו במפורש שלא להיות אוניברסליות.

כדי להבין מדוע מרבית השפות הינן אוניברסליות, נשים לב לכך שכדי להראות ששפה
מסוימת~$𝓛$ היא שפה אוניברסלית, מספיק להראות שיש ב-$𝓛$ תכנית אוניברסלית~$ℓ_𝓤$
עבור שפה אחת בלבד~$𝓤$, ובלבד שהשפה~$𝓤$ היא אוניברסלית מצידה. כך למשל, אם ידוע
ששפת מיני-ליספ היא אוניברסלית, הרי האינטרפר~\begin{english}\verb|m|\end{english} של מיני-ליספ~הכתוב
בשפת~\E|C| מוכיח כי אף שפת~\E|C| היא אוניברסלית:

\begin{quote}
כאמור, האינטרפטר הוא תכנית~$ℓ_{\text{mLisp}}$ שהוא אוניברסלית בעבור מיני-ליספ,
והכתובה בשפת~\E|C|. כיוון שמיני-ליספ היא אוניברסלית הרי לכל שפת תכנות אחרת~$𝓠$
קיימת תכנית אוניברסלית מתאימה~$ℓ_𝓠$ במיני-ליספ. תכנית אוניברסלית~$c_𝓠$ הכתובה
בשפת~\E|C| בעבור השפה~$𝓠$, מתקבלת באמצעות הפעלה האינטרפטר~\texttt{l} על~$ℓ_𝓠$.
על~$ℓ_𝓠$.

בפרט, נזכור כי האינטרפטר ממומש כתכנית בשפת~\E|C|. תכנית זו ניתן לתקן בקלות כך
שמקום להפעיל האינטרפטר על תכנית כלשהי של מיני-ליספ, הוא יוגבל לפעול על
התכנית~$ℓ_𝓠$, ועליה בלבד. תכנית מתוקנת זו היא בדיוק התכנית אוניברסלית~$C_𝓠$.
\end{quote}

התיאור לעיל של המונח "פונקציה אוניברסלית" איננו הגדרה מתימטית, והוא דורש, למשל,
ניסוח מדויק יותר של משמעות פעולת "ההרצה", או, ביאור משמעות הטענה בדבר שקילות
של שתי הרצות. הגדרה מתימטית של אלו אינה ענין פשוט: ראשיתה בשנות השלושים של
המאה העשרים, עוד טרם פיתוח שפות תכנות כלשהן, בעבודות של מתימטקאים ולוגיקאים
מפורסמים†{%
  נאמר שמתימטיקאי הוא \ע|מפורסם| אם קיים משפט או מונח מתימטי הקרוים על שמו:
  מרחבי הילברט, משפט הרברנד, משפטי אי השלמות של גדל, פונקצית אקרמן, אלגברת
  קלין, מכונת טיורינג, ארכיטקטורת פון-נוימן ומשפט צ'רץ'-רוסר הופכים על כן את
  \E|Hilbert|, \E|Hebrand|, \E|Hebrand|, \E|Go\"del|, \E|Ackerman|, \E|Kleene|,
  \E|Turing|, \E|von Neumann|, \E|Church| ו-\E|Rosser| למתימטיקאים מפורסמים.
} כגון דוד הילברט (\E|Hilbert|), וילהלם אקרמן \E|Ackerman|, סטפן קלין
(\E|Kleene|) קורט גדל (\E|Go\"del|) וז'ק הרברנד (\E|Hebrand|, ושימוש בלוגיקה
מתימטית לשם הגדרה תיאורטית של קבוצה של פונקציות מתימטיות הידועה בשם \ע|קבוצת
הפונקציות הרקורסיביות הכלליות|, או בקיצור, \ע|הפונקציות הרקורסיביות|. הגדרה זו,
סופה שהתפתחה להגדרות מדויקות של מונחים כגון חישוב, הרצה, ושקילות.

דיוק שכזה חורג מגבולות הדיון כאן אשר די לו בהבנה אינטואיטיבית בסיסית של מושגים
אלו: הרצה היא הפעלה של תכנית, אשר יכולה לכלול בתוכה גם הידור, ושתי הרצות
הןבסיסית שקולות אם הפלט שלהן זהה.

המונח חישוב יכלול עבורנו פעולות כגון בדיקה של תנאים וקריאה לפונקציות. אך לא
נכלול במונח חישוב פעולות כגון בדיקת מיקום העכבר, או תצוגה גרפית, וזאת מהשיקול
הבא:
\begin{quote}
  אם השפה~$𝓠$ תומכת בפעולה)כגון תצוגה גרפית($α$,כך ש-$α$ אינה יכולה להיות
  ממומשת באמצעות מבנים אחרים של~$𝓠$, והשפה~$𝓛$ אינה תומכת ב-$α$. הרי אמנם לא
  ניתן לכתוב ב-$𝓛$ תכנית אוניברסלית עבור~$𝓠$, אולם, אם ישנו מימוש עבור
  השפה~$𝓠$, ניתן לתקן את~$𝓛$ באמצעות הוספת הפעולה~$α$ לשפת התכנות.
\end{quote}

§ מכונת טיורינג והסברה של טיורינג וצ'רץ'

קושי מובנה נוסף בתיאור המילולי ולא פורמלי של שפות תכנות אוניברסליות, הוא בדרישה
כי קיימת בה תוכנית אוניברסלית בשפה עבור כל שפת תכנות אחרת. וכי מה הכוונה במונח
המעורפל "כל שפת תכנות אחרת"?

מסקנתנו כי ניתן לזהות שפה תכנות כאוניברסלית על ידי כתיבה של תכנית אוניברסלית
אחת בלבד בה עבור שפה אוניברסלית מסוימת אחרת, מצמצמת מעט את השאלה. הרי די לנו
לבנות שפת תכנות אוניברסלית אחת, השפה האוניברסלית ה"ראשונית" והראשונה. רק בבניה
זו נידרש להפיג את הערפל מעל המונח "כל שפת תכנות אחרת", ולו פעם אחת בלבד.

שפת התכנות הראשונית הזו אינה שפה, אלא מחשב, מחשב פשוט מאוד, אך מחשב שלא נבנה
מעולם. מחשב זה ידוע בשם מכונת טיורינג: באותן שנות השלושים בהן עמלו מתימטיקאים
ולוגיקאים על הגדרת קבוצות הפונקציות הרקורסיביות, פעל גם אלן טיורינג)Turing(,
מתימטיקאי בעצמו, אך גם אחד ממדעני המחשב הראשונים. טיורינג השתמש בהגדרה זו של
קבוצת הפונקציות הרקורסיביות ובהתפתחויות אחרות במתימטיקה, לשם ניסוח מדויק של
המונח \ע|חישוב|, ותיאור מדויק כיצד חישוב יכול להעשות הן באופן מוכני בידי אדם
ןהן בידי מכונה.

באותה תקופה טרם נבנו מחשבים דיגיטליים; חישוב ממוכן אז נעשה בשיטה האנאלוגית,
בה גודל פיזיקלי כגון מרחק או מתח חשמלי ייצג ערך נומרי המתקבל או נוצר במהלך
החישוב. אשר על כן תיאר טיורינג באורח תיאורטי בלבד מכונת חישוב פשוטה מאוד, מכונה
הקרויה כעת על שמו \ע|מכונת-טיורינג|, המסוגלת לבצע "כל חישוב שהוא". טיורינג לא
ראה אפשרות או צורך בבניה בפועל של מכונה כזו, והוא אף הסביר כיצד ללא הפעלת כל
מאמץ אינטלקואלי, יוכל כל אדם לחקות את פעולתה של מכונת טיורינג תוך שימוש בדף
ועט.

אכן, מכונת טיורינג לא נבנתה מעולם, שכן, כפי שנראה בהמשך, איך בכך צורך או תועלת:
מכונה כזו תהיה בהכרח איטית מאוד, וכתיבת תכניות בעבורה היא מסורבלת במיוחד. לעומת
זאת, מכונות טיורינג וירטואליות קיימות לרוב, זאת)גם(כיוון שקל מאוד לבצע אמולציה
של מכונת טיורינג ברוב שפות התכנות.

מכונת טיורינג†{%
  ישנן הגדרות רבות ושונות של מכונת טיורינג. אנו משתמשים כאן בהגדרה הפשוטה ביותר
  המתאימה לצרכי הדיון.
}
מקבלת קלט מסרט בודד (\E|tape|). מבנה הסרט שתיאר טיורינג מזכיר את הסרטים
המגנטיים (\E|magnetic tapes|) שאמנם פותחו שנים ספורות לפני כן, אך טרם נוצלו
כהתקן זיכרון של מחשב. סרט הוא רצועה אינסופית, אך חד כיוונית של תאים. כל אחד
מתאים אלו עשוי להכיל שני סימבולים שונים. ניתן לסמן שני סימבולים אלו
בספרות~$0$ ו-\E|$1$|, אולם מכונת טיורינג אינה משתמשת בסימבולים אלו כמספרים.

המכונה מייצרת את הפלט שלה על אותו הסרט עצמו עליו היא מקבלת את הקלט.

לבד מהסרט, מכונת טיורינג מצוידת בראש קריאה/כתיבה, הניצב בתחילת החישוב על התא
הראשון בסרט, ואשר בכל נקודה במהלך החישוב על תא אחד מבין התאים שעל הסרט. למכונת
טיורינג יש גם \ע|מצב פנימי|, אותו ניתן לתאר במונחים של שפות תכנות מודרניות
כמשתנה בודד, אשר יכול להכיל ערכים מוצבים ערכים הלקוחים מקבוצה סופית כלשהי. קיים
גם ערך אחד מיוחד בקבוצה זו, הקובע את המצב הפנימי בתחילת פעולתה של המכונה.

קבוצת המצבים יכול להיות, למשל, קבוצת המספרים~$1…N$ עבור ערך מתאים של~$N$, וניתן
גם להניח כי המספר~$1$ הוא המצב התחילי של המכונה. בכל זאת, מכונת טיורינג אינה
יכולה לבצע חישובים עם מספרים אלו, אלא לבדוק את ערכם בלבד.

מכונת טיורינג מגדירה מעין שפת תכנות הקובעת כיצד תפעל המכונה, רשימת הנחיות המגדירה
\ספרר
✦ מתי מסתיים החישוב, ומתי סיום זה יחשב כהצלחה
✦ באלו תנאים על המכונה להזיז את הקריאה/כתיבה
✦ אלו נתונים על המכונה לכתוב על הסרט, ובאילו נסיבות
===

מבנה רשימת ההנחיות הזו, או "שפת התכנות" של מכונות טיורינג הוא מנוונת מאוד מאוד.
תכנית בשפה זו היא אוסף של פקודות פשוטות, הדומות במבנה שלהן לפקודות בשפת מכונה.
ישנם חמישה סוגים של פקודות אותן מכירה מכונת טיורינג:

\begin{quote}
\begin{enumerate}
  ✦~$⟨n⇒✓⟩$ פקודה הקובעת כי על המכונה לעצור את החישוב מיידית בכל עת שהמצב
  הפנימי הוא~$n$; הפלט של המכונה ימצא אז על הסרט.
  ✦~$⟨n⇒ ✗⟩$ פקודה הקובעת כי על המכונה לעצור והודיע כי החישוב נכשל בכל עת
    שהמצב הפנימי הוא~$n$; לתכנו של הסרט אין משמעות כאשר החישוב נכשל.
  ✦~$⟨n, h⇒-, n'⟩$ פקודה הקובעת כי בכל עת שהמכונה נמצאת במצב~$n$
    והסימבול עליו מצביע ראש הקריאה/כתיבה הוא~$h$, \E|$h∈❴~0,l❵$| על המכונה
    לעבור למצב~$n'$, ולהזיז ראש זה צעד אחד שמאלה, כלומר, לכיוון תחילת הסרט.
  ✦~$⟨n,h⇒+, n'⟩$ פקודה דומה לפקודה הקודמת, אלא שתזוזת הראש היא
    צעד אחד ימינה, כלומר לכיוון הצד האינסופי של הסרט.
  ✦~$⟨n,h⇒ h', n'⟩$ פקודה הקובעת כי באותם תנאים, על המכונה להחליף את תוכן התא
  עליו מצביע הראש מהסימבול~$h$ לסימבול \E|$h'∈❴0,1❵$|.
\end{enumerate}
\end{quote}

אוסף הפקודות הזה אינו מסודר. בכל איטרציה של החישוב בוחרת המכונה את הפקודה
המתאימה למצב הפנימי הנוכחי שלה ולתוכן התא המצוי תחת ראש/הקריאה כתיבה, ומבצעת
פקודה זו. ניתן להניח כי האוסף אינו מכיל פקודות סותרות, וכי אוסף הפקודות השונות
מכסה את כל האפשרויות השונות בהן עשויה להיתקל המכונה)יש לכל היותר~$2·N$ אפשרויות
כאלו.(וכי החישוב אינו מזיז לעולם את ראש הקריאה/כתיבה שמאלה אל מעבר לתא הראשון
שבסרט.

בהינתן פשטות פעולתה של מכונת טיורינג, ופשטותה של "שפת התכנות" שמאחוריה, מובן
מאליו כי קל לכתוב, כמעט בכל שפת תכנות ובוודאי בפסקל או ב-\E|C|, תכנית
אוניברסלית עבור מכונות טיורינג, כלומר תכנית המבצעת אמולציה של ריצתה של מכונת
טיורינג. שפת תכנות היא טיורינג שלמה אם ניתן לכתוב בה תכנית אוניברסלית בעבור
מכונת טיורינג. למעשה, קשה לחשוב על שפת תכנות שהיא כה פשוטה עד שלא ניתן יהיה
לכתוב בה תכנית אוניברסלית שכזו.

ניתן להניח שבסופם של הנתונים הרשומים על הסרט שמקבלת מכונת טיורינג ישנו סימן
מיוחד (למשל סידרה של תריסר מופעים של הסימבול~$0$(. באופן דומה, נניח שטרם שמכונת
טיורינג מסיימת את עבודתה, היא טורחת לכתוב סימן זה בסוף הסרט.

משמעו של הסימן המיוחד הזה הוא שבהינתן תכנית, רשימת הנחיות מסוימת, למכונת
טיורינג, זו מחשבת פונקציה חלקית מסוימת מהקבוצה~$❴0,1❵^*$ אל עצמה. הפונקציה היא
חלקית, לא רק משום שמכונת טיורינג עשויה לעצור את החישוב ולהודיע שהוא נכשל, אלא
בעיקר, בגלל שמכונת טיורינג עשויה להכנס ללולאה אינסופית.

כל תכנית מגדירה פונקציה אחת כזו, אך כמובן יתכן שאותה פונקציה תוגדר על ידי מספר
תכניות. טיורינג התעניין בקבוצת כל הפונקציות שאפשר לחשב באמצעות באמצעות המכונה
שתכנן.

הזיהוי בין תכונת ה"אוניברסליות" של שפה ובין היותה טיורינג שלמה ראשיתו בהוכחה של
טיורינג לפיה ניתן לחשב כל פונקציה רקורסיבית באמצעות תכנית מתאימה של מכונת
טיורינג, ולהיפך, כל פונקציה אותה יכולה לחשב מכונת טיורינג היא פונקציה
רקורסיבית. בניסוח אחר, קבוצת כל הפונקציות החלקיות אותן יכולה לחשב מכונת
טיורינג, היא בדיוק קבוצת הפונקציות הרקורסיביות.

בד בבד עם עבודתו זו של טיורינג, פיתח אלונזו צ'רץ' (\E|Church|) מודל
מתימטי אחר לתיאור האופן שבו נעשים חישובים. מודל זה קרוי תחשיב ה-$λ$, אותו
התחשיב עליו תתבסס שפת ליספ, שלוש עשרה שנים מאוחר יותר. תחשיב ה-$λ$ שונה בתכלית
ממכונת טיורינג. הפעולה היסודית בתחשיב היא הפעלה של פונקציה על ערכים שאף הם עשוי
שיהיו פונקציות. אולם המושגים של פונקציה והפעלה של פונקציה אינם קיימים מופיעים
בהגדרתה של מכונת טיורינג. ומהצד האר, פעולות כגון קריאה וכתיבה של ערכים או שינוי
ערכו משתנה מצב פנימי הן זרות בתכלית לתחשיב ה-$λ$.

משנתברר כי תחשיב ה-$λ$ שקול למכונת טיורינג, במובן זה שניתן לכתוב בתחשיב תכנית
אוניברסלית עבור "שפת התכנות" של מכונת טיורינג, ושניתן לתכנת מכונת טיורינג כך
שתחקה את התחשיב, ובהתבסס על השקילות בין מכונות טיורינג ובין קבוצת הפונקציות
הרקורסיביות, ניסחו צ'רץ' וטיורינג את הסברה הקרויה \E|The Church Turing Thesis|.

סברה זו, שאינה משפט מתימטי, נותנת מענה לשאלה "מהי כל שפת תכנות אחרת?" וזאת
בקביעה כי \ע|כל חישוב במודל חישובי "סביר", ניתן להעשות גם באמצעות מכונת
טיורינג|. הסברה אינה קובעת מהו מודל חישובי סביר, ולכן היא פורשת כנפיה על
מודלים של חישוב אשר טרם נודעו. בכל זאת, בחלוף שבעים שנה מניסוח הסברה,
איש לא הצליח להפריך את הסברה באמצעות הצגת מודל חישובי אשר נראה "סביר"
בעיני הקהילה המדעית, ולו גם מקצתה שבמקצתה.

הסברה של צ'רץ' וטיורינג מבהירה את הסיבה בגללה שפת תכנות שהיא טיורינג שלמה קרויה
שפה אוניברסלית. מהסברה נובע עי שפה אשר יכולה לבצע אמולציה של מכונת טיורינג,
יכולה לבצע אמולציה של כל מודל חישובי סביר אחר.†{%
  המכורים למשחק המחשב Minecraft ישמחו לשמוע כי היה מי שבנה מכונת טיורינג
  באמצעות \E|redstone|. המשחק לכן אינו רק מהנה, הוא גם אוניברסלי!}

§ אלגנטיות של שפת תכנות

ברור כי יש להבחין בין אוניברסליות ובין יעילות: על אף שליספ ופסקל הן שתיהן
אוניברסליות, הרי תכניות הכתובות בליספ תדרושנה בדרך כלל יותר משאבים מתוכניות
שקולות להן הכתובות בפסקל.

באופן דומה, יש להבחין גם בין אוניברסליות ובין נוחותו של המתכנת בכתיבת תכניות
בשפה: כיוון ששפת \E|C++| תומכת במבנים תכנותיים מתקדמים כגון מחלקות, העמסה של
אופרטורים ופונקציות, אשר נעדרים משפת \E|C| נוכל לטעון ש-\E|C| חלשה יותר
מ-\E|C++|. אך חולשה זו היא ענין של נוחותו של המתכנת. כיוון ש=\E|C| היא
אוניברסלית, הרי לא זו בלבד שניתן, במאמץ מסוים, לכתוב בה כל תכנית שאפשר לכתוב
בשפת~\E|C++|, אלא שניתן גם לחקות ב-\E|C| את המבנים המתקדמים של~\E|C++|, אף זאת
במחיר של מאמץ תכנותי.

ישנם מדדים מספריים להשוואה בין שפות תכנות אוניברסליות מבחינת יעילות החישוב בהן.
אולם, כיצד ניתן להשוות שפות תכנות מבחינת נוחות התכנות בהן, וכיצד נבחין בין
נוחות, ובין טעם אישי של מתכנת זה או אחר?

לכאורה, מיטוב "נוחות התכנות" יכול להעשות באמצעות שפות תכנות האוספות אל תוכן כל
מבנה תכנותי מתקדם אותו ניתן להעלות על הדעת, אלא ששפות אספניות נוטות לקרוס תחת
כובד משקלן: נדרש מאמץ אנושי לא מבוטל כדי ללמוד כיצד לתכנת בהן, ונדרש מאמץ גדול
אף יותר כדי לתכנן, לממש ולתמוך בכל המבנים הללו.

ג'ון מקארת'י התמודד עם השאלה הזו, כשהציג לראשונה את ליספ. הוא הראה אמנם שליספ
היא שפה אוניברסלית, בכך שהיא יכולה לחשב כל פונקציה שיכולה לחשב מכונת טיורינג,
אבל הוא רצה גם להוכיח באופן זה או אחר שליספ אלגנטית יותר ממכונת טיורינג. לשם
כך, הוא הפעיל את השיקול הבא: אם שפה היא אוניברסלית, אז אפשר לכתוב ב-$𝓛$ תכנית
אוניברסלית עבור~$𝓛$ עצמה. כך, כיוון שמכונת טיורינג היא אוניברסלית, ניתן לכתוב
עבורה תכנית אוניברסלית אחת, שתחקה את פעולתה של כל תכנית אחרת של מכונת טיורינג.

הקלט של התכנית האוניברסלית הזו יהיה התכנית האחרת, שאת פעולתה יש לחקות. לשם כך,
תקודד רשימת הפקודות של התכנית באמצעות הסימבולים~$0$ ו-$1$, ותיכתב על הסרט של
התכנית האוניברסלית. בהמשך הסרט, יש לכתוב את הקלט של התכנית המקורית.

באורח דומה, ניתן לכתוב בליספ תכנית אוניברסלית בעבור ליספ עצמה, והפונקציה
\E|eval|~\ref{eq:eval} שכתב מקארת'י היא בדיוק פונקציה אוניברסלית עצמית כזו.
בצדק טען מקארת'י שתכנית אוניברסלית עבור מכונת טיורינג תהיה ארוכה ומסורבלת.
אמנם המשימה המוטלת על התכנית האוניברסלית של מכונת טיורינג היא פשוטה ביחס, אולם
הפקודות הבסיסיות של מכונת טיורינג הן כה חלשות שיהיה צורך לכתוב רבות מאוד מהן
כדי לבצע משימה זו.

לעומת זאת, התכנית האוניברסלית העצמית של ליספ נדרשת לבצע משימה קשה יותר: בגלל
שהפעולות הבסיסיות של ליספ אותם היא נדרשת לחקות, מורכבות יותר מהפקודות הפשוטות
של מכונת טיורינג. אולם, לרשות התכנית בליספ עומדים כלים חזקים יותר כדי לעשות
זאת. העובדה שניתן לממש את eval כל כך בקלות, כך טען מקארת'י, היא עדות לאלגנטיות
של ליספ.

נכליל את השיקול הזה, ונשתמש באורך התכנית האוניברסלית העצמית של שפת תכנות כמדד
לאלגנטיות של השפה: אם השפה מורכבת ומתוחכמת, הרי, מחד, קל יותר לכתוב את התכנית
הזו, אך מאידך, על התכנית לעסוק בכל המורכבות והתיחכום הזה. לחילופין, שפה שהיא
פשוטה מאוד כמו מכונת טיורינג (וגם כמו שפת ה-\E|batch| של מערכת ההפעלה \קד{DOS})
שהוזכרה מעלה, היא קלה יותר לעיבוד ולביצוע, אבל הפשטות של השפה מהווה אבן נגף
בבואנו להשתמש בה כדי לכתוב את התכנית האוניברסלית העצמית.

בניסוח אחר: ככל שהתכנית אוניברסלית העצמית של שפת תכנות מסוימת קצרה יותר, כך
נראה שהבחירה והארגון של המבנים התכנותיים בשפה "נכונה" יותר: בחירה שהיא מספיק
חזקה כדי לממש את עצמה בתמציתיות.ככל שהשפה מציעה מבנים מתקדמים יותר, כך קל יותר
ו"נוח" יותר לממש בה תכנית אוניברסלית עצמית. אולם, ככל שיש יותר מבנים כאלו, וככל
שהם מתקדמים יותר, כך נדרשת התכנית האוניברסלית העצמית לבצע יותר.

הנה מספר נתונים על אורכן של תכניות אוניברסליות עצמית.
\begin{enumerate}
    ✦ מהדר לשפת C הכתוב בשפה C עצמה, דורש כמה עשרות אלפי שורות.
    ✦ שפת \E|C+++| העשירה הרבה יותר מ-\E|C|, אינה מועילה לקיצור המהדר. המהדר
    של \E|gcc| מתפרס על פני כשבעה מיליון שורות קוד.
    ✦ המהדר הראשון לשפת פסקל, אשר נכתב בשפת פסקל דרש כשבעת אלפים ומאתיים שורות.
    ✦ כפי שראינו כאן, הפונקציה האוניברסלית \קד{eval} בעבור מיני-ליספ,
    ✦ לעומת זאת, מפרש בסיסי לשפת התכנות פרולוג הכתוב בפרולוג יכול להכתב בשורה
    אחת בלבד, ומפרש מתוחכם, המאפשר למשל מעקב אחרי החישוב, לא ידרוש בדרך כלל
    יותר מעשר שורות.
\end{enumerate}

§ מימוש שפת תכנות באמצעות עצמה

מתברר שמקובל מאוד לכתוב את המהדר של השפה בשפה עצמה. כך למשל, המהדר של שפת~\E|C|
כתוב בִּשְׂפַת \סי. המהדר של שפת \גאוה כתוב בִּשְׂפַת \גאוה, וכו'. כמובן שהדבר מעורר
קושי: כי אם המהדר עבור שפה מסוימת כתוב באותה שפה, הרי כיצד הודר המהדר? התשובה
הפשוטה היא שהמהדר הידר את עצמו, וכך הם בדרך כלל פני הדברים. אלא, שהדבר מוביל
לרקורסיה אינסופית.

בכל זאת, בשפות תכנות, ניתן לבצע תהליך של \E|bootstrapping| שבאמצעותו ניתן לפתח
מהדר המסוגל להדר את עצמו. התהליך דומה מאוד למה שהיה עושה נפח עני שברשותו ברזל,
אך לא כסף לרכישת צבת. נפח כזה היה משתמש בכבשנו באופן איטרטיבי, כאשר בכל פעם הוא
היה משתמש בגוש הברזל הדומה ביותר לצבת שיש ברשותו, כדי ליצר קירוב טוב יותר לצבת.

תהליך ה-\E|bootstrapping| (שעדות לו נמצאת ב\פנה|איור:מימוש|) מציע את השיטה
האיטרטיבית הבאה למימוש שפת תכנות חדשה באמצעות עצמה:

ראשית יש להגדיר תת שפה ראשונית של השפה החדשה אותם רוצים לממש. כך עשינו כשהגדרנו
את מיני-ליספ. לאחר מכן, יש לכתוב את המהדר לתת השפה הזו באמצעות עצמה. את המהדר
הראשון של שפת המכונה ניתן לתרגם ידנית לשפת מכונה. אפשרות אחרת היא לתקן ולשנות מהדר
של שפת תכנות קיימת, כך שיתמוך בתת השפה הראשונית. כך נעשה במימוש הראשוני של פסקל.

לאחר ההידור ההתחלתי של המהדר הראשון, נהדר אותו באמצעות עצמו. אחר כך, המהדר
הראשון יורחב כך שיתמוך בתת שפה שניה, מעט גדולה יותר. גם מהדר זה יוכל להדר את
עצמו, ולאחר שכך יקרה, ניתן לשפר את המהדר תוך שימוש בתכונות של תת-השפה השניה.
כדי ליצור מהדר לשפה החדשה שתומך בכל מרכיביה, יש להמשיך ולחזור ככל שידרש על
תהליך ה-\E|bootstrapping|: הרחבת המהדר כך שיתמוך בתכונות נוספות של השפה,
ושיכתוב המהדר כך שישתמש בתכונות אלו.

§ בעיית העצירה

\begin{tabularx}\textwidth{XX}
אֵין תָּכְנִית שֶתֵּדַע מָה אֲחֶרֶת עוֹשָׂה.\newline
זוֹ עֻבְדָּה מוּצָקָה, וְלֹא סְתָם מְצוּצָה:\newline
תּוּכָל עַד מָחָר אֶת הַמֹּח לִשְבֹּר\newline
לֹא תּוּכַל לְנַבֵּא אִם תָּכְנִית תַּעֲצֹר.\newline
&
ניתן להוכיח באורח מתימטי מדוייק שלא קיימת תכנית (בשפת תכנות כלשהי) ש"יודעת" מה
תכנית אחרת עושה. בפרט, לא קיימת תכנית כללית, אשר מצליחה לנבא אם תכנית אחרת
נתונה עוצרת, מבלי להריץ אותה.⏎
\\
נַנִּיחַ שֶ-$P$ הִיא שִיטָה שֶכָּזֹאת
שֶלְּתוֹך כָּל תָּכְנִית מְצִיצָה, לְגַּלּוֹת \newline
שֶאֵין שוּם לוּלָאָה אֵינְסוֹפִית מִסְתַּחְרֶרֶת; \newline
וְאִם אֵין שָם כְּלוּם- אָז 'טוֹב!' הִיא אוֹמֶרֶת. \newline
& תרגום לעברית \\

מְזִינִים אֶת הַקּוֹד וְאֶת כָּל הַנְּתוּנִים,\newline
וְ-$P$ אָז תַּחֲקֹר בַּפְּרָטִים הַקְּטַנִּים\newline
וּתְחַשְבֵּן אִם הַכֹּל מִסְתַּדֵּר כָּרָאוּי\newline
(בְּנִגּוּד לְמַצָּב לוּלָאִי לֹא רָצוּי).\newline
& תרגום לעברית \\

הָאֱמֶת הִיא שֶ-$P$ כָּזוֹ לֹא תִּתָּכֵן,\newline
כִּי אִם תִּכָּתֵב~$P$, וְלִי תִּנָּתֵן,\newline
אֶשְתַּמֵּש בָּהּ לִצֹּר כֶּשֶל לוֹגִי מֻצְלָח\newline
שֶיִּשְבֹּר הֶגְיוֹנְךָ וְחוּשֶיךָ יִמְעַךְ.\newline
& תרגום לעברית \\

הַתַּכְסִיס הוּא פָּשוּט וְיוֹצֵא מִן הַכְּלָל.\newline
אַגְדִּיר עוֹד תָּכְנִית, בְּשֵם~$Q$, לְמָשָל,\newline
שֶתִּקַּח כָּל תָּכְנִית, וּלְ-$P$ אָז תִּקְרָא,\newline
שֶתִּקְבַּע אִם יֵש בָּהּ לוּלָאָה מַמְאִירָה;\newline
& תרגום לעברית \\

אִם יֵש, אָז~$Q$ תַּדְפִּיס 'אוּף!' וְתִפְרֹש;\newline
אַךְ אִם אֵין, אָז~$Q$ תַּחֲזֹר לָהּ לָרֹאש,\newline
וְתַתְחִיל מֵחָדָש, תִּסְתּוֹבֵב בְּלִי לַחֲדֹל,\newline
עַד יִגְוַע הַיְּקוּם וְיִקְפָּא וְיִבֹּל.\newline
& תרגום לעברית \\

הַתָּכְנִית הַזּוֹ,~$Q$, לֹא תֻּשְאַר יְתוֹמָה;\newline
מַמְזֵר שֶכְּמוֹתִי- אַפְעִילָהּ עַל עַצְמָהּ!\newline
אֵיךְ~$Q$ תִּתְנַהֵג בְּמַצָּב שֶכָּזֶה?\newline
כְּשֶתִּקְרָא אֶת עַצְמָהּ- מָה בְּדִיּוּק תַּעֲשֶׂה?\newline
& תרגום לעברית \\

אִם~$P$ תְּגַלֶּה לוּלָאָה-~$Q$ תֵּצֵא;\newline
אַךְ~$P$ אֲמוּרָה לְדַוֵּחַ עַל זֶה.\newline
כָּךְ שֶאִם~$Q$ תֵּצֵא- אָז~$P$ תֹּאמַר 'טוֹב!'\newline
וְQ תֵּאָלֵץ לְהַתְחִיל שוּב לָסֹב!\newline
& תרגום לעברית \\

מָה שֶ-$P$ לֹא תַּגִּיד,~$Q$ יָשָר מְעַקֶּמֶת;\newline
$Q$ גוֹרֶמֶת לְ-$P$ לָצֵאת דֵּי מְטֻמְטֶמֶת.\newline
כִּי אִם~$P$ צוֹדֶקֶת- יוֹצֵא שֶשִּקְּרָה;\newline
וְאִם מְשַקֶּרֶת- אֱמֶת הִיא דִּבְּרָה!\newline
& תרגום לעברית \\

כָּזֶה פָּרָדוֹקְס אֱלֶגָנְטִי יָצָא,\newline
פָּשוּט בִּגְלַל~$P$, הַהֲלִיך הַמֻּמְצָא.\newline
אִם תַּנִּיחַ שֶ-$P$ אֲמִתִּי- הִסְתַּבַּכְתָּ;\newline
בְּפַח הַיּוֹקְשִים שֶטָּמַנְתִּי- נִלְכַּדְתָּ!\newline
& תרגום לעברית \\

אָז אֵיך נֵחָלֵץ מִצָּרָה כֹּה סְבוּכָה?\newline
לֹא צָרִיךְ שֶאַגִּיד; תְּנַחֵש לְבַדְּךָ.\newline
מַסְקָנָה הֶכְרֵחִית, שֶבְּזֶה הָעוֹלָם,\newline
יְצוּר אֲגָדִי כְּמוֹ~$P$ לֹא קַיָּם.\newline
& תרגום לעברית \\

לֹא תַּצְלִיחַ לִבְנוֹת מִין מִתְקָן שֶכָּזֶה\newline
שֶיּוּכַל לְנַבֵּא מָה מַחְשֵב יַעֲשֶׂה.\newline
זֶה בִּלְתִּי אֶפְשָרִי. וְלָכֵן אֲנָשִים\newline
מוֹצְאִים בָּאגִים לְבַד; מַחְשֵבִים הֵם טִפְּשִים!!\newline
& תרגום לעברית \\
\end{tabularx}
